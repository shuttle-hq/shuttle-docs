---
title: "Your First Shuttle App"
description: "Learn to build and deploy your first web application with Shuttle from scratch"
icon: "rocket"
---

## Learning Objectives

By the end of this tutorial, you will:

- Understand what Shuttle is and how it works
- Build a complete web application with a database
- Deploy your app to the cloud with a single command
- Understand Infrastructure from Code principles

## Prerequisites

- Basic Rust knowledge (variables, functions, structs)
- Familiarity with command line tools
- [Rust installed](https://rustup.rs/) on your machine
- [Docker installed](https://docs.docker.com/get-docker/) (for local database)

**Time Required**: 30-45 minutes

## What We're Building

We'll create a simple **Personal Journal** web application where users can:

- Create journal entries through a REST API
- View all entries stored in a database
- Store data in a PostgreSQL database (automatically provisioned)
- Deploy to production with HTTPS

By the end, you'll have a live web application on the internet!

## Step 1: Install Shuttle CLI

First, let's install the Shuttle command-line tool:

```bash
cargo install cargo-shuttle
```

This will take a few minutes to compile and install.

Verify the installation worked:

```bash
shuttle --version
```

You should see output like `cargo-shuttle 0.56.0`. If you see an error, make sure `~/.cargo/bin` is in your PATH.

**What to notice**: The Shuttle CLI is how we'll create projects, run them locally, and deploy to production.

## Step 2: Create Your Account

Sign up and login to Shuttle:

```bash
shuttle login
```

This will open your browser to the Shuttle Console where you can sign up with Google, GitHub, or email. After signing up, return to your terminal.

You should see a success message: `Logged in successfully!`

**What to notice**: This authentication lets Shuttle know which projects belong to you and enables deployment.

## Step 3: Initialize Your Project

Create a new Shuttle project:

```bash
shuttle init --template axum personal-journal
cd personal-journal
```

This creates a new directory with starter files. Let's look at what was generated:

```bash
ls -la
```

You should see:

```
.gitignore
Cargo.toml
src/
```

Let's examine the starting code:

```bash
cat src/main.rs
```

You'll see this basic Axum application:

```rust
use axum::{routing::get, Router};

async fn hello_world() -> &'static str {
    "Hello, world!"
}

#[shuttle_runtime::main]
async fn main() -> shuttle_axum::ShuttleAxum {
    let router = Router::new().route("/", get(hello_world));

    Ok(router.into())
}
```

**What to notice**:

- The `#[shuttle_runtime::main]` macro wraps your app for Shuttle
- The return type `shuttle_axum::ShuttleAxum` tells Shuttle this is an Axum web app
- This is a complete web application in just a few lines!

## Step 4: Test Your First App

Run your app locally to verify everything works:

```bash
shuttle run
```

You should see output like:

```
Starting personal-journal on http://127.0.0.1:8000
```

Open a new terminal and test your app:

```bash
curl http://localhost:8000
```

You should see: `Hello, world!`

You can also visit `http://localhost:8000` in your browser. Press `Ctrl+C` in the first terminal to stop the server.

**What to notice**: Your app is running locally with live reloading. Any code changes will automatically restart the server.

## Step 5: Add Database Dependencies

Now let's add a PostgreSQL database to store journal entries. Update your `Cargo.toml` file:

```toml
[package]
name = "personal-journal"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.8"
shuttle-axum = "0.56.0"
shuttle-shared-db = "0.56.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "chrono", "uuid"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
tokio = { version = "1.0", features = ["macros"] }
tower = "0.5"
tower-http = { version = "0.6", features = ["cors"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

Build to download dependencies:

```bash
cargo build
```

This will take a few minutes the first time. You should see `Finished dev [unoptimized + debuginfo] target(s)`.

**What to notice**: We've added `shuttle-shared-db` which will automatically provision a PostgreSQL database, and `sqlx` for database queries.

## Step 6: Create Data Models

Create a new file for our data structures:

```bash
touch src/models.rs
```

Add this content to `src/models.rs`:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct JournalEntry {
    pub id: Uuid,
    pub title: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateEntryRequest {
    pub title: String,
    pub content: String,
}
```

Test that it compiles:

```bash
cargo check
```

You should see `Finished dev [unoptimized + debuginfo] target(s)`.

**What to notice**:

- `JournalEntry` represents a row in our database
- `CreateEntryRequest` represents the JSON data users send to create entries
- Serde annotations handle JSON conversion automatically

## Step 7: Set Up Database Migrations

Create a migrations directory:

```bash
mkdir migrations
```

Create your first migration file:

```bash
touch migrations/20231201000000_create_journal_entries.sql
```

Add this SQL to the migration file:

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE journal_entries (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**What to notice**: This creates our database table. The filename timestamp ensures migrations run in order.

## Step 8: Build the Web Application

Now let's update our main application. Replace the contents of `src/main.rs`:

```rust
mod models;

use axum::{
    extract::{State, Json},
    http::StatusCode,
    response::Json as ResponseJson,
    routing::{get, post},
    Router,
};
use models::{JournalEntry, CreateEntryRequest};
use sqlx::PgPool;
use tower_http::cors::CorsLayer;

// Application state that will be shared across handlers
#[derive(Clone)]
struct AppState {
    pool: PgPool,
}

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] pool: PgPool,
) -> shuttle_axum::ShuttleAxum {
    // Run database migrations
    sqlx::migrate!("./migrations").run(&pool).await.unwrap();

    // Create application state
    let state = AppState { pool };

    // Build our application with routes
    let router = Router::new()
        .route("/", get(hello))
        .route("/entries", get(get_entries))
        .route("/entries", post(create_entry))
        .layer(CorsLayer::permissive())
        .with_state(state);

    Ok(router.into())
}

// Handler functions
async fn hello() -> &'static str {
    "Welcome to your Personal Journal! Visit /entries to see your entries."
}

async fn get_entries(
    State(state): State<AppState>,
) -> Result<ResponseJson<Vec<JournalEntry>>, StatusCode> {
    let entries = sqlx::query_as::<_, JournalEntry>(
        "SELECT id, title, content, created_at FROM journal_entries ORDER BY created_at DESC"
    )
    .fetch_all(&state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(ResponseJson(entries))
}

async fn create_entry(
    State(state): State<AppState>,
    Json(payload): Json<CreateEntryRequest>,
) -> Result<ResponseJson<JournalEntry>, StatusCode> {
    let entry = sqlx::query_as::<_, JournalEntry>(
        "INSERT INTO journal_entries (title, content) VALUES ($1, $2)
         RETURNING id, title, content, created_at"
    )
    .bind(&payload.title)
    .bind(&payload.content)
    .fetch_one(&state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(ResponseJson(entry))
}
```

Build to check for errors:

```bash
cargo build
```

You should see `Finished dev [unoptimized + debuginfo] target(s)`.

**What to notice**:

- The `#[shuttle_shared_db::Postgres]` annotation automatically gives us a database
- We have three endpoints: `/` (welcome), `GET /entries` (list), and `POST /entries` (create)
- Shuttle automatically runs our migrations on startup

## Step 9: Test Your Complete Application

Now let's test our complete application with database functionality:

```bash
shuttle run
```

You should see:

```
Starting personal-journal on http://127.0.0.1:8000
```

**Test the welcome page**:

```bash
curl http://localhost:8000
```

Expected output: `Welcome to your Personal Journal! Visit /entries to see your entries.`

**Test getting entries** (should be empty initially):

```bash
curl http://localhost:8000/entries
```

Expected output: `[]` (empty JSON array)

**Create your first entry**:

```bash
curl -X POST http://localhost:8000/entries \
  -H "Content-Type: application/json" \
  -d '{"title": "My First Entry", "content": "Today I learned about Shuttle!"}'
```

You should see JSON output with your entry including an ID and timestamp:

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "title": "My First Entry",
  "content": "Today I learned about Shuttle!",
  "created_at": "2023-12-01T10:30:00Z"
}
```

**Get entries again to see your entry**:

```bash
curl http://localhost:8000/entries
```

You should now see an array with your journal entry!

**What to notice**: Your app is fully functional with database persistence. Data survives between requests and server restarts.

## Step 10: Deploy to Production

Now comes the magic moment - deploying to production with a single command:

```bash
shuttle deploy
```

This process will:

1. Build your application (may take 2-3 minutes)
2. Provision a PostgreSQL database automatically
3. Deploy your app to AWS
4. Set up HTTPS and give you a URL

You'll see output like:

```
Deployment finished successfully.
Service Name:  personal-journal
Deployment ID: 01234567-89ab-cdef-0123-456789abcdef
Status:        running
Last Updated:  2023-12-01T10:30:00Z
URI:           https://personal-journal-abc123.shuttle.app
```

**What to notice**: Shuttle provisioned everything automatically - no configuration files, no manual database setup, no SSL certificates to manage!

## Step 11: Test Your Live Application

Your app is now live on the internet! Test it with your actual deployment URL:

```bash
# Replace with your actual URL from the deploy output
curl https://personal-journal-abc123.shuttle.app
```

Expected output: `Welcome to your Personal Journal! Visit /entries to see your entries.`

**Create an entry in production**:

```bash
curl -X POST https://personal-journal-abc123.shuttle.app/entries \
  -H "Content-Type: application/json" \
  -d '{"title": "Deployed!", "content": "My app is live on the internet!"}'
```

**Verify it was saved**:

```bash
curl https://personal-journal-abc123.shuttle.app/entries
```

You should see your entry! Your database in production is completely separate from your local one.

**What to notice**: Your app works identically in production and locally, but the production version is accessible from anywhere in the world with HTTPS.

## What You've Accomplished

Congratulations! You've just:

✅ **Built a complete web application** with REST API endpoints  
✅ **Added a PostgreSQL database** with automatic provisioning  
✅ **Deployed to production** with HTTPS and a custom subdomain  
✅ **Experienced Infrastructure from Code** - no configuration files needed!

## Key Concepts You've Learned

### Infrastructure from Code

Notice how we got a database with just this annotation:

```rust
#[shuttle_shared_db::Postgres] pool: PgPool,
```

No database setup, no connection strings, no environment variables - Shuttle handled everything!

### Automatic Resource Provisioning

When you deployed, Shuttle:

- Analyzed your code to see you needed a database
- Provisioned PostgreSQL automatically in the cloud
- Connected your app to the database securely
- Set up HTTPS and gave you a URL

### Type Safety

Shuttle checks your resource requirements at compile time, preventing many deployment issues before they happen.

### Development-Production Parity

Your local development environment automatically mirrors production, reducing deployment surprises.

## Next Steps

Now that you understand the basics, you can:

1. **Add a web frontend** - Create HTML pages for your journal with templates
2. **Learn about secrets** - Add API keys and configuration with `shuttle-secrets`
3. **Try other databases** - Explore AWS RDS for production workloads
4. **Add authentication** - Secure your journal with user accounts
5. **Add more features** - Edit/delete entries, search, categories

Try our [REST API with Axum tutorial](/tutorials/rest-http-service-with-axum) or [Authentication tutorial](/tutorials/authentication) next!

## What We Covered

- ✅ Setting up your development environment
- ✅ Creating your first Shuttle project
- ✅ Adding a database with annotations
- ✅ Building REST API endpoints with JSON
- ✅ Testing locally with real database
- ✅ Deploying to production with one command
- ✅ Understanding Infrastructure from Code

You now have the foundation to build and deploy Rust web applications with Shuttle. The best part? This same pattern works for much more complex applications - Shuttle scales with your needs!

## Troubleshooting

**App won't start locally?**

- Make sure Docker is running (needed for local database)
- Check that all dependencies are in `Cargo.toml`
- Try `cargo clean && cargo build` to rebuild

**Build errors?**

- Ensure your `Cargo.toml` matches the one in Step 5 exactly
- Check that `src/models.rs` was created properly
- Verify the migration file exists in `migrations/`

**Database connection issues?**

- Ensure your migrations are in the `migrations/` folder
- Check that `sqlx::migrate!()` is called in your main function
- Make sure Docker is running for local development

**Deployment failed?**

- Run `shuttle project status` to check your project
- View logs with `shuttle logs`
- Ensure you're logged in with `shuttle login`

**JSON parsing errors?**

- Verify your request has `Content-Type: application/json` header
- Check that field names in your JSON match the struct exactly
- Use single quotes around your curl command's JSON data

Ready to build something amazing? Check out our other tutorials for more advanced features!
