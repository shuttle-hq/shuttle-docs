---
title: "Your First Shuttle App"
description: "Learn Shuttle fundamentals by building and deploying a web application with Infrastructure from Code"
icon: "rocket"
---

## Learning Objectives

By completing this tutorial, you'll master **foundational Shuttle concepts** and learn to:

- **Shuttle Runtime**: Use `#[shuttle_runtime::main]` for serverless deployment
- **Infrastructure from Code**: Provision databases with `#[shuttle_shared_db::Postgres]`
- **Zero-Config Deployment**: Deploy with `shuttle deploy` - no YAML or containers needed
- **Local Development**: Test locally with `shuttle run` before deploying
- **CLI Workflow**: Use Shuttle CLI for project management and deployment

## Prerequisites

- **Time Required**: 10 minutes
- **Rust**: Version 1.75.0 or later ([install here](https://rustup.rs/))
- **Tools**: [Shuttle CLI installed](/getting-started/installation)
- **Accounts**: None required (Shuttle account created automatically)
- **Experience**: Basic Rust knowledge (functions, structs, async/await)

## What We're Building

We'll create **Personal Notes** - a web application for storing and managing personal notes with full-text search capabilities.

The app demonstrates Shuttle's core value: turning Rust code into production infrastructure with zero configuration.

**High-level components:**

- **Web API** (Axum framework)
- **PostgreSQL Database** (auto-provisioned by Shuttle)
- **Database Migrations** (SQLx schema management)
- **Static File Serving** (HTML frontend)
- **Full-text Search** (PostgreSQL FTS)

## Tutorial Steps

### Step 1: Create Your First Project

Initialize a new Shuttle project:

```bash
shuttle init personal-notes
cd personal-notes
```

This creates a new directory with a basic Rust web application. Shuttle automatically generates:

- `Cargo.toml` with dependencies
- `src/main.rs` with a Hello World server
- `.gitignore` with Shuttle-specific entries

### Step 2: Understand the Generated Code

Examine `src/main.rs`:

```rust
use axum::{response::Html, routing::get, Router};

async fn hello_world() -> Html<&'static str> {
    Html("<h1>Hello, world!</h1>")
}

#[shuttle_runtime::main]
async fn main() -> shuttle_axum::ShuttleAxum {
    let router = Router::new().route("/", get(hello_world));

    Ok(router.into())
}
```

**Key concepts:**

- `#[shuttle_runtime::main]` - Shuttle's deployment runtime
- `shuttle_axum::ShuttleAxum` - Return type for Axum apps
- `Router::new()` - Standard Axum routing

### Step 3: Test Locally

Run your app locally:

```bash
shuttle run
```

Visit `http://localhost:8000` to see your app. Press `Ctrl+C` to stop.

**What happened:** Shuttle starts a local server that mimics the production environment.

### Step 4: Add Database Infrastructure

Update `Cargo.toml` to include database support:

```toml
[dependencies]
axum = "0.7.0"
shuttle-axum = "0.56.0"
shuttle-runtime = "0.56.0"
shuttle-shared-db = "0.56.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "macros"] }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
```

### Step 5: Create Data Models

Create `src/models.rs`:

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Note {
    pub id: i32,
    pub title: String,
    pub content: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreateNote {
    pub title: String,
    pub content: String,
}
```

### Step 6: Add Database Schema

Create database initialization in `src/database.rs`:

```rust
use sqlx::PgPool;

pub async fn initialize_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
        CREATE TABLE IF NOT EXISTS notes (
            id SERIAL PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- Add full-text search index
        CREATE INDEX IF NOT EXISTS notes_search_idx
        ON notes USING gin(to_tsvector('english', title || ' ' || content));
        "#
    )
    .execute(pool)
    .await?;

    Ok(())
}
```

### Step 7: Build the API

Update `src/main.rs` with full application logic:

```rust
mod models;
mod database;

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::{Html, Json},
    routing::{get, post},
    Router,
};
use database::initialize_database;
use models::*;
use serde::Deserialize;
use sqlx::PgPool;
use std::collections::HashMap;

#[derive(Deserialize)]
struct SearchQuery {
    q: Option<String>,
}

// API Handlers
async fn create_note(
    State(pool): State<PgPool>,
    Json(note): Json<CreateNote>,
) -> Result<Json<Note>, StatusCode> {
    let note = sqlx::query_as!(
        Note,
        r#"
        INSERT INTO notes (title, content)
        VALUES ($1, $2)
        RETURNING id, title, content, created_at
        "#,
        note.title,
        note.content
    )
    .fetch_one(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(note))
}

async fn get_notes(
    State(pool): State<PgPool>,
    Query(params): Query<SearchQuery>,
) -> Result<Json<Vec<Note>>, StatusCode> {
    let notes = if let Some(search_term) = params.q {
        // Full-text search
        sqlx::query_as!(
            Note,
            r#"
            SELECT id, title, content, created_at
            FROM notes
            WHERE to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', $1)
            ORDER BY created_at DESC
            "#,
            search_term
        )
    } else {
        // Get all notes
        sqlx::query_as!(
            Note,
            "SELECT id, title, content, created_at FROM notes ORDER BY created_at DESC"
        )
    }
    .fetch_all(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(notes))
}

async fn get_note(
    State(pool): State<PgPool>,
    Path(id): Path<i32>,
) -> Result<Json<Note>, StatusCode> {
    let note = sqlx::query_as!(
        Note,
        "SELECT id, title, content, created_at FROM notes WHERE id = $1",
        id
    )
    .fetch_optional(&pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
    .ok_or(StatusCode::NOT_FOUND)?;

    Ok(Json(note))
}

async fn frontend() -> Html<&'static str> {
    Html(include_str!("../static/index.html"))
}

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] pool: PgPool,
) -> shuttle_axum::ShuttleAxum {
    // Initialize database schema
    initialize_database(&pool)
        .await
        .expect("Failed to initialize database");

    // Build router with API and frontend
    let router = Router::new()
        .route("/", get(frontend))
        .route("/api/notes", get(get_notes).post(create_note))
        .route("/api/notes/:id", get(get_note))
        .with_state(pool);

    Ok(router.into())
}
```

### Step 8: Add Frontend Interface

Create `static/index.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Personal Notes</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 40px;
      }
      .note {
        border: 1px solid #ddd;
        padding: 20px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .note h3 {
        margin: 0 0 10px 0;
        color: #333;
      }
      .note .date {
        color: #666;
        font-size: 0.9em;
      }
      .form {
        background: #f5f5f5;
        padding: 20px;
        border-radius: 5px;
        margin-bottom: 20px;
      }
      input,
      textarea {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      button {
        background: #007cba;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }
      button:hover {
        background: #005a87;
      }
      .search {
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <h1>üìù Personal Notes</h1>

    <div class="search">
      <input
        type="text"
        id="searchInput"
        placeholder="Search notes..."
        onkeyup="searchNotes()"
      />
    </div>

    <div class="form">
      <h3>Add New Note</h3>
      <input type="text" id="title" placeholder="Note title" />
      <textarea id="content" placeholder="Note content" rows="4"></textarea>
      <button onclick="addNote()">Add Note</button>
    </div>

    <div id="notes"></div>

    <script>
      async function loadNotes(search = "") {
        const url = search
          ? `/api/notes?q=${encodeURIComponent(search)}`
          : "/api/notes";
        const response = await fetch(url);
        const notes = await response.json();

        const notesDiv = document.getElementById("notes");
        notesDiv.innerHTML = notes
          .map(
            (note) => `
                <div class="note">
                    <h3>${note.title}</h3>
                    <p>${note.content}</p>
                    <div class="date">Created: ${new Date(
                      note.created_at
                    ).toLocaleString()}</div>
                </div>
            `
          )
          .join("");
      }

      async function addNote() {
        const title = document.getElementById("title").value;
        const content = document.getElementById("content").value;

        if (!title || !content) {
          alert("Please fill in both title and content");
          return;
        }

        await fetch("/api/notes", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ title, content }),
        });

        document.getElementById("title").value = "";
        document.getElementById("content").value = "";
        loadNotes();
      }

      function searchNotes() {
        const search = document.getElementById("searchInput").value;
        loadNotes(search);
      }

      // Load notes on page load
      loadNotes();
    </script>
  </body>
</html>
```

### Step 9: Test Your Complete App

Run the full application:

```bash
shuttle run
```

Test the functionality:

1. Visit `http://localhost:8000`
2. Add some notes through the web interface
3. Try searching for specific content
4. Verify the API endpoints work

### Step 10: Deploy to Production

Deploy your Personal Notes app:

```bash
shuttle deploy
```

Your app is now live! Shuttle provides you with a unique URL where your application runs 24/7.

**What happened:**

- Shuttle built your Rust code
- Provisioned a PostgreSQL database
- Deployed your app to production infrastructure
- Made it accessible via HTTPS

## What You've Learned

You've mastered these **key Shuttle concepts**:

- **Infrastructure from Code** - Database provisioned with a simple function parameter
- **Zero-Config Deployment** - Production deployment without Docker or YAML files
- **Shuttle Runtime** - `#[shuttle_runtime::main]` handles all infrastructure concerns
- **Local Development** - `shuttle run` provides production-like local testing
- **Automatic HTTPS** - Production apps get SSL certificates automatically
- **Database Integration** - `#[shuttle_shared_db::Postgres]` provides managed PostgreSQL
- **Static File Serving** - Frontend and API served from the same deployment

## Troubleshooting

**Database connection errors?**

- Shuttle automatically provisions PostgreSQL - no setup needed
- Check that your schema initialization completed successfully

**Local development not working?**

- Ensure you're in the project directory when running `shuttle run`
- Check that port 8000 is available

**Deployment failures?**

- Verify your code compiles locally first with `cargo build`
- Check deployment logs with `shuttle logs`

**Frontend not loading?**

- Ensure `static/index.html` exists in your project
- Check that the root route serves the HTML file

## Next Steps

Continue your Shuttle journey:

1. **Add Authentication** - Learn user management with [Authentication Tutorial](/tutorials/intermediate/authentication)
2. **Build APIs** - Explore REST patterns with [REST API Tutorial](/tutorials/beginner/rest-http-service-with-axum)
3. **Database Mastery** - Deep dive with [Database Tutorial](/tutorials/beginner/databases-with-rust)
