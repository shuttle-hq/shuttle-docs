---
title: "Discord Weather Forecast Bot"
description: "Learn to build and deploy a Discord bot with external API integration using Shuttle's secrets management"
icon: "robot"
---

## Learning Objectives

By completing this tutorial, you'll master **Shuttle Discord bot development** and learn to:

- **Shuttle Secrets Management**: Securely handle Discord tokens and API keys in production
- **External API Integration**: Connect to third-party services (OpenWeatherMap) with proper error handling
- **Discord Bot Infrastructure**: Use Shuttle's Discord runtime for seamless deployment
- **Production Bot Hosting**: Deploy 24/7 Discord bots with zero configuration
- **Infrastructure from Code**: Define bot permissions and commands declaratively

## Prerequisites

- Basic understanding of Discord bots and slash commands
- [Shuttle CLI installed](/getting-started/installation)
- Discord account with server access for testing
- Basic familiarity with async Rust and HTTP requests

**Time Required**: 35-45 minutes

## What We're Building

We'll create **WeatherBot** - a production Discord bot with real-time weather data:

- **Slash Command Interface** - Modern `/weather <city>` commands
- **Real-Time Weather Data** - Integration with OpenWeatherMap API
- **Error Handling** - Graceful handling of invalid cities and API failures
- **Rich Formatting** - Weather data with emojis and structured responses
- **Secure Deployment** - Production-ready bot with proper secrets management

Users can get instant weather forecasts for any city worldwide through Discord.

## Tutorial Steps

### Step 1: Register Your Discord Bot

Create a Discord application and bot:

**Discord Developer Portal Setup:**

1. Visit [Discord Developer Portal](https://discord.com/developers/applications)
2. Click "New Application" ‚Üí Name it "WeatherBot" ‚Üí "Create"
3. Navigate to "Bot" ‚Üí "Add Bot" ‚Üí "Yes, do it!"
4. Copy the **Bot Token** (keep this secret!)
5. Copy the **Application ID** from the General Information tab

**Add Bot to Your Server:**
Replace `<APPLICATION_ID>` with your Application ID:

```
https://discord.com/oauth2/authorize?client_id=<APPLICATION_ID>&scope=bot+applications.commands&permissions=2048
```

Open this URL, select your Discord server, and authorize the bot.

### Step 2: Get Weather API Access

Register for OpenWeatherMap API access:

1. Sign up at [OpenWeatherMap](https://openweathermap.org/api)
2. Navigate to "API keys" in your account dashboard
3. Copy your **API Key** (free tier: 1,000 calls/day)

### Step 3: Initialize Your Shuttle Discord Project

Create a new Discord bot project:

```bash
shuttle init --template serenity weather-bot
cd weather-bot
```

Update `Cargo.toml` with external API dependencies:

```toml
[package]
name = "weather-bot"
version = "0.1.0"
edition = "2021"

[dependencies]
# Shuttle Discord runtime
shuttle-runtime = "0.56.0"
shuttle-serenity = "0.56.0"
shuttle-secrets = "0.56.0"

# Discord bot framework
serenity = { version = "0.12", default-features = false, features = ["client", "gateway", "rustls_backend", "model"] }

# External API integration
reqwest = { version = "0.11", features = ["json"] }
serde = { version = "1.0", features = ["derive"] }

# Utilities
anyhow = "1.0"
tokio = "1.28"
tracing = "0.1"
```

### Step 4: Configure Shuttle Secrets

Create `Secrets.toml` for secure credential management:

```toml
DISCORD_TOKEN = "your_discord_bot_token"
OPENWEATHER_API_KEY = "your_openweather_api_key"
```

Add to `.gitignore` to protect secrets:

```bash
echo "Secrets.toml" >> .gitignore
```

### Step 5: Define Weather Data Models

Create `src/weather.rs` for API integration:

```rust
use serde::Deserialize;
use std::fmt;

#[derive(Debug, Deserialize)]
pub struct WeatherResponse {
    pub weather: Vec<WeatherCondition>,
    pub main: MainWeather,
    pub name: String,
    pub sys: CountryInfo,
}

#[derive(Debug, Deserialize)]
pub struct WeatherCondition {
    pub main: String,
    pub description: String,
    pub icon: String,
}

#[derive(Debug, Deserialize)]
pub struct MainWeather {
    pub temp: f64,
    pub feels_like: f64,
    pub humidity: u32,
    pub pressure: u32,
}

#[derive(Debug, Deserialize)]
pub struct CountryInfo {
    pub country: String,
}

impl WeatherResponse {
    // Convert Kelvin to Celsius
    pub fn temp_celsius(&self) -> i32 {
        (self.main.temp - 273.15).round() as i32
    }

    pub fn feels_like_celsius(&self) -> i32 {
        (self.main.feels_like - 273.15).round() as i32
    }

    // Get weather emoji based on condition
    pub fn weather_emoji(&self) -> &str {
        match self.weather[0].main.as_str() {
            "Clear" => "‚òÄÔ∏è",
            "Clouds" => "‚òÅÔ∏è",
            "Rain" => "üåßÔ∏è",
            "Drizzle" => "üå¶Ô∏è",
            "Thunderstorm" => "‚õàÔ∏è",
            "Snow" => "‚ùÑÔ∏è",
            "Mist" | "Fog" => "üå´Ô∏è",
            _ => "üå§Ô∏è",
        }
    }
}

impl fmt::Display for WeatherResponse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} **Weather in {}, {}**\n\
            üå°Ô∏è **{}¬∞C** (feels like {}¬∞C)\n\
            {} **{}**\n\
            üíß Humidity: **{}%** | üìä Pressure: **{} hPa**",
            self.weather_emoji(),
            self.name,
            self.sys.country,
            self.temp_celsius(),
            self.feels_like_celsius(),
            self.weather_emoji(),
            self.weather[0].description,
            self.main.humidity,
            self.main.pressure
        )
    }
}

#[derive(Debug)]
pub enum WeatherError {
    CityNotFound(String),
    ApiError(String),
    NetworkError,
}

impl fmt::Display for WeatherError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WeatherError::CityNotFound(city) => write!(f, "‚ùå City '{}' not found. Please check the spelling and try again.", city),
            WeatherError::ApiError(msg) => write!(f, "üîß Weather service error: {}", msg),
            WeatherError::NetworkError => write!(f, "üåê Network error. Please try again later."),
        }
    }
}

pub struct WeatherService {
    api_key: String,
    client: reqwest::Client,
}

impl WeatherService {
    pub fn new(api_key: String) -> Self {
        Self {
            api_key,
            client: reqwest::Client::new(),
        }
    }

    pub async fn get_weather(&self, city: &str) -> Result<WeatherResponse, WeatherError> {
        let url = format!(
            "https://api.openweathermap.org/data/2.5/weather?q={}&appid={}",
            urlencoding::encode(city),
            self.api_key
        );

        tracing::info!("Fetching weather for city: {}", city);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(|_| WeatherError::NetworkError)?;

        match response.status() {
            reqwest::StatusCode::OK => {
                let weather: WeatherResponse = response
                    .json()
                    .await
                    .map_err(|e| WeatherError::ApiError(format!("Failed to parse response: {}", e)))?;

                tracing::info!("Successfully fetched weather for {}, {}", weather.name, weather.sys.country);
                Ok(weather)
            }
            reqwest::StatusCode::NOT_FOUND => {
                Err(WeatherError::CityNotFound(city.to_string()))
            }
            status => {
                Err(WeatherError::ApiError(format!("API returned status: {}", status)))
            }
        }
    }

    // Get weather for multiple cities (for future expansion)
    pub async fn get_weather_batch(&self, cities: &[&str]) -> Vec<(String, Result<WeatherResponse, WeatherError>)> {
        let mut results = Vec::new();

        for city in cities {
            let result = self.get_weather(city).await;
            results.push((city.to_string(), result));
        }

        results
    }
}
```

Add URL encoding dependency to `Cargo.toml`:

```toml
urlencoding = "2.1"
```

### Step 6: Implement Discord Bot with Slash Commands

Update `src/main.rs` with the complete bot implementation:

```rust
mod weather;

use anyhow::Context as _;
use serenity::async_trait;
use serenity::builder::{CreateCommand, CreateCommandOption, CreateInteractionResponse, CreateInteractionResponseMessage};
use serenity::model::application::{CommandOptionType, Interaction};
use serenity::model::gateway::Ready;
use serenity::prelude::*;
use shuttle_runtime::SecretStore;
use std::sync::Arc;
use tracing::{error, info, warn};
use weather::{WeatherService, WeatherError};

struct WeatherBot {
    weather_service: Arc<WeatherService>,
}

#[async_trait]
impl EventHandler for WeatherBot {
    async fn interaction_create(&self, ctx: Context, interaction: Interaction) {
        if let Interaction::ApplicationCommand(command) = interaction {
            let start_time = std::time::Instant::now();

            let response_content = match command.data.name.as_str() {
                "weather" => {
                    self.handle_weather_command(&command.data.options).await
                }
                "forecast" => {
                    self.handle_forecast_command(&command.data.options).await
                }
                "help" => {
                    self.handle_help_command()
                }
                _ => {
                    warn!("Unknown command: {}", command.data.name);
                    "‚ùì Unknown command. Use `/help` to see available commands.".to_string()
                }
            };

            let response_time = start_time.elapsed();
            tracing::info!("Command '{}' processed in {:?}", command.data.name, response_time);

            let data = CreateInteractionResponseMessage::new()
                .content(response_content)
                .ephemeral(false); // Make responses visible to everyone

            let builder = CreateInteractionResponse::Message(data);

            if let Err(why) = command.create_interaction_response(&ctx.http, builder).await {
                error!("Cannot respond to slash command: {}", why);
            }
        }
    }

    async fn ready(&self, ctx: Context, ready: Ready) {
        info!("ü§ñ {} is connected and ready!", ready.user.name);

        let commands = vec![
            CreateCommand::new("weather")
                .description("Get current weather for any city")
                .add_option(
                    CreateCommandOption::new(CommandOptionType::String, "city", "City name")
                        .required(true)
                        .description("Enter the name of the city you want weather for")
                ),
            CreateCommand::new("forecast")
                .description("Get weather for multiple cities")
                .add_option(
                    CreateCommandOption::new(CommandOptionType::String, "cities", "Cities separated by commas")
                        .required(true)
                        .description("Enter city names separated by commas (e.g., London, Paris, Tokyo)")
                ),
            CreateCommand::new("help")
                .description("Show help information about WeatherBot commands")
        ];

        match ready.user.id.global_commands(&ctx.http, commands).await {
            Ok(registered_commands) => {
                info!("‚úÖ Successfully registered {} slash commands", registered_commands.len());
                for cmd in registered_commands {
                    info!("   ‚Ä¢ /{} - {}", cmd.name, cmd.description);
                }
            }
            Err(why) => {
                error!("‚ùå Failed to register slash commands: {}", why);
            }
        }
    }
}

impl WeatherBot {
    async fn handle_weather_command(&self, options: &[serenity::model::application::CommandDataOption]) -> String {
        let city = options
            .iter()
            .find(|opt| opt.name == "city")
            .and_then(|opt| opt.value.as_ref())
            .and_then(|val| val.as_str())
            .unwrap_or("London");

        match self.weather_service.get_weather(city).await {
            Ok(weather) => weather.to_string(),
            Err(error) => error.to_string(),
        }
    }

    async fn handle_forecast_command(&self, options: &[serenity::model::application::CommandDataOption]) -> String {
        let cities_input = options
            .iter()
            .find(|opt| opt.name == "cities")
            .and_then(|opt| opt.value.as_ref())
            .and_then(|val| val.as_str())
            .unwrap_or("London,Paris,Tokyo");

        let cities: Vec<&str> = cities_input
            .split(',')
            .map(|s| s.trim())
            .filter(|s| !s.is_empty())
            .take(5) // Limit to 5 cities to avoid hitting Discord message limits
            .collect();

        if cities.is_empty() {
            return "‚ùå Please provide at least one city name.".to_string();
        }

        let results = self.weather_service.get_weather_batch(&cities).await;
        let mut response = format!("üåç **Weather Forecast for {} Cities**\n\n", results.len());

        for (city, result) in results {
            match result {
                Ok(weather) => {
                    response.push_str(&format!(
                        "**{}**: {} {}¬∞C\n",
                        weather.name,
                        weather.weather_emoji(),
                        weather.temp_celsius()
                    ));
                }
                Err(WeatherError::CityNotFound(_)) => {
                    response.push_str(&format!("**{}**: ‚ùå Not found\n", city));
                }
                Err(_) => {
                    response.push_str(&format!("**{}**: ‚ö†Ô∏è Error\n", city));
                }
            }
        }

        response
    }

    fn handle_help_command(&self) -> String {
        "ü§ñ **WeatherBot Help**\n\n\
        **Available Commands:**\n\
        ‚Ä¢ `/weather <city>` - Get current weather for a specific city\n\
        ‚Ä¢ `/forecast <cities>` - Get weather for multiple cities (comma-separated)\n\
        ‚Ä¢ `/help` - Show this help message\n\n\
        **Examples:**\n\
        ‚Ä¢ `/weather London`\n\
        ‚Ä¢ `/weather New York`\n\
        ‚Ä¢ `/forecast Tokyo, Paris, Sydney`\n\n\
        **Features:**\n\
        ‚Ä¢ üå°Ô∏è Real-time temperature and conditions\n\
        ‚Ä¢ üíß Humidity and pressure data\n\
        ‚Ä¢ üåç Worldwide city coverage\n\
        ‚Ä¢ ‚ö° Fast response times\n\n\
        Powered by OpenWeatherMap API | Built with Shuttle".to_string()
    }
}

#[shuttle_runtime::main]
async fn main(
    #[shuttle_secrets::Secrets] secrets: SecretStore,
) -> shuttle_serenity::ShuttleSerenity {
    // Initialize structured logging
    tracing_subscriber::fmt()
        .with_target(false)
        .init();

    info!("üöÄ Starting WeatherBot initialization...");

    // Get secrets using Shuttle's secure secret management
    let discord_token = secrets
        .get("DISCORD_TOKEN")
        .context("DISCORD_TOKEN not found in secrets - add it to Secrets.toml")?;

    let weather_api_key = secrets
        .get("OPENWEATHER_API_KEY")
        .context("OPENWEATHER_API_KEY not found in secrets - add it to Secrets.toml")?;

    // Initialize weather service
    let weather_service = Arc::new(WeatherService::new(weather_api_key));
    info!("‚úÖ Weather service initialized");

    // Configure Discord gateway intents (minimal for slash commands)
    let intents = GatewayIntents::empty(); // No message content needed for slash commands

    // Create Discord client with weather bot handler
    let client = Client::builder(&discord_token, intents)
        .event_handler(WeatherBot { weather_service })
        .await
        .context("Failed to create Discord client")?;

    info!("‚úÖ Discord client configured successfully");

    Ok(client.into())
}
```

### Step 7: Test Your Weather Bot Locally

Test the bot before deployment:

```bash
shuttle run
```

You should see:

```
üöÄ Starting WeatherBot initialization...
‚úÖ Weather service initialized
‚úÖ Discord client configured successfully
ü§ñ WeatherBot is connected and ready!
‚úÖ Successfully registered 3 slash commands
   ‚Ä¢ /weather - Get current weather for any city
   ‚Ä¢ /forecast - Get weather for multiple cities
   ‚Ä¢ /help - Show help information about WeatherBot commands
```

**Test Commands in Discord:**

- `/weather London` - Should return detailed weather for London
- `/forecast Tokyo, Paris, New York` - Should show weather for multiple cities
- `/help` - Should display command information

### Step 8: Deploy to Production

Deploy your bot for 24/7 operation:

```bash
shuttle deploy
```

Your bot will be built, deployed, and start running in production. Test all commands to ensure they work correctly.

### Step 9: Monitor and Maintain Your Bot

**View Production Logs:**

```bash
shuttle logs
```

**Monitor Bot Performance:**

- Check response times in logs
- Monitor API usage (OpenWeatherMap dashboard)
- Verify bot uptime in Discord server

**Update Bot (when needed):**

```bash
shuttle deploy  # Redeploys with latest changes
```

## What You've Learned

You've successfully built and deployed a production Discord bot and mastered:

### Shuttle Discord Bot Development

- **Secrets Management** with `#[shuttle_secrets::Secrets]` for secure token handling
- **Discord Runtime** with `shuttle-serenity` for zero-config deployment
- **Production Hosting** with automatic uptime and error recovery
- **Structured Logging** for debugging and monitoring

### External API Integration Patterns

- **HTTP Client Configuration** with proper error handling
- **Response Parsing** with Serde for JSON APIs
- **Rate Limiting Awareness** for third-party API usage
- **Error Propagation** with user-friendly Discord messages

### Discord Bot Best Practices

- **Modern Slash Commands** for better user experience
- **Command Registration** with descriptions and options
- **Rich Message Formatting** with emojis and structured responses
- **Error Handling** for network failures and invalid inputs

## Troubleshooting

**Bot appears offline?**

- Verify `DISCORD_TOKEN` in `Secrets.toml` is correct
- Check bot permissions in Discord server settings
- Review deployment logs with `shuttle logs`

**Weather commands failing?**

- Confirm `OPENWEATHER_API_KEY` is valid and active
- Check API usage limits (1,000 calls/day on free tier)
- Test with common city names first

**Slash commands not registering?**

- Discord can take up to 1 hour to propagate global commands
- Try re-inviting the bot with fresh permissions
- Check bot has `applications.commands` scope

**"Secrets not found" errors?**

- Ensure `Secrets.toml` exists in project root
- Verify secret names match exactly (case-sensitive)
- Check `Secrets.toml` is not in `.gitignore` for local testing

## Next Steps

Enhance your Discord bot with advanced features:

1. **Database Integration** - Store user preferences and weather history ([Database Tutorial](/tutorials/beginner/databases-with-rust))
2. **Scheduled Notifications** - Send daily weather reports to channels
3. **Weather Alerts** - Notify users of severe weather conditions
4. **Multiple API Sources** - Compare data from different weather services
5. **Web Dashboard** - Create a web interface for bot management ([Multi-Service Tutorial](/tutorials/advanced/custom-service))

Your WeatherBot demonstrates how Shuttle simplifies Discord bot development with secure secrets management and seamless external API integration!

## Complete Code

Find the complete working code for this tutorial in our [examples repository](https://github.com/shuttle-hq/shuttle-examples/tree/main/discord-weather-bot).
