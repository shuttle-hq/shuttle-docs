---
title: "Building a Multi-Service Application"
description: "Learn to combine Discord bots with web APIs in a single Shuttle service using custom runtime patterns"
icon: "boxes-stacked"
---

## Learning Objectives

By completing this tutorial, you'll master **Shuttle multi-service patterns** and learn to:

- **Shuttle Custom Services**: Implement the `Service` trait for specialized runtime behavior
- **Service Composition**: Combine Discord bots, web APIs, and background tasks in one deployment
- **Shared Resource Management**: Use Shuttle's dependency injection with custom services
- **Concurrent Runtime Patterns**: Handle multiple async services with proper error handling
- **Infrastructure from Code**: Define complex service architectures declaratively

## Prerequisites

- Completed [Discord Weather Bot](/tutorials/advanced/discord-weather-forecast) tutorial
- Understanding of async Rust and concurrent programming
- [Shuttle CLI installed](/getting-started/installation)
- Discord account and test server for bot development

**Time Required**: 45-60 minutes

## What We're Building

We'll create **BotCommand Central** - a unified Discord bot and web dashboard:

- **Discord Bot Service** - Slash commands with usage analytics
- **Web Dashboard Service** - Real-time statistics and control panel
- **Background Analytics** - Continuous metrics collection and reporting
- **Shared State Management** - Cross-service data synchronization
- **Health Monitoring** - Service health checks and automatic recovery

Users can interact with the bot in Discord while monitoring performance through a web interface.

## Tutorial Steps

### Step 1: Initialize Custom Service Project

Create a new project without templates for maximum control:

```bash
shuttle init --template none botcommand-central
cd botcommand-central
```

Examine the minimal structure:

```bash
cat src/main.rs
```

You'll see:

```rust
#[shuttle_runtime::main]
async fn main() -> shuttle_runtime::ShuttleAxum {
    todo!()
}
```

Update `Cargo.toml` with multi-service dependencies:

```toml
[package]
name = "botcommand-central"
version = "0.1.0"
edition = "2021"

[dependencies]
# Shuttle runtime and resources
shuttle-runtime = "0.56.0"
shuttle-secrets = "0.56.0"
shuttle-shared-db = "0.56.0"

# Web framework
axum = { version = "0.7", features = ["json"] }
tower-http = { version = "0.5", features = ["cors", "fs"] }

# Discord bot
poise = "0.6"
serenity = { version = "0.12", default-features = false, features = ["client", "gateway", "rustls_backend", "model"] }

# Async runtime and utilities
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "macros", "chrono"] }
chrono = { version = "0.4", features = ["serde"] }
tracing = "0.1"
tracing-subscriber = "0.3"

# Utilities
anyhow = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
```

### Step 2: Define Multi-Service Architecture

Create `src/models.rs` for shared data structures:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceMetrics {
    pub service_name: String,
    pub command_count: u64,
    pub error_count: u64,
    pub uptime_seconds: u64,
    pub last_activity: Option<DateTime<Utc>>,
    pub health_status: HealthStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandStats {
    pub command_name: String,
    pub execution_count: u64,
    pub average_response_time_ms: f64,
    pub last_executed: Option<DateTime<Utc>>,
    pub error_rate: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemOverview {
    pub total_commands: u64,
    pub active_services: Vec<ServiceMetrics>,
    pub recent_commands: Vec<CommandStats>,
    pub system_uptime: u64,
    pub overall_health: HealthStatus,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
    pub timestamp: DateTime<Utc>,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            timestamp: Utc::now(),
        }
    }

    pub fn error(message: &str) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(message.to_string()),
            timestamp: Utc::now(),
        }
    }
}
```

### Step 3: Implement Shared State Management

Create `src/state.rs` for cross-service data management:

```rust
use crate::models::*;
use sqlx::PgPool;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{Utc, Duration};
use std::collections::HashMap;

#[derive(Clone)]
pub struct AppState {
    pub pool: PgPool,
    pub metrics: Arc<RwLock<HashMap<String, ServiceMetrics>>>,
    pub command_stats: Arc<RwLock<HashMap<String, CommandStats>>>,
    pub start_time: std::time::Instant,
}

impl AppState {
    pub fn new(pool: PgPool) -> Self {
        Self {
            pool,
            metrics: Arc::new(RwLock::new(HashMap::new())),
            command_stats: Arc::new(RwLock::new(HashMap::new())),
            start_time: std::time::Instant::now(),
        }
    }

    // Record command execution with timing
    pub async fn record_command(&self, command_name: &str, response_time_ms: f64, success: bool) {
        // Update database
        if let Err(e) = sqlx::query!(
            r#"
            INSERT INTO command_logs (command_name, execution_time, response_time_ms, success, created_at)
            VALUES ($1, NOW(), $2, $3, NOW())
            "#,
            command_name,
            response_time_ms,
            success
        )
        .execute(&self.pool)
        .await {
            tracing::error!("Failed to log command: {}", e);
        }

        // Update in-memory stats
        let mut stats = self.command_stats.write().await;
        let entry = stats.entry(command_name.to_string()).or_insert(CommandStats {
            command_name: command_name.to_string(),
            execution_count: 0,
            average_response_time_ms: 0.0,
            last_executed: None,
            error_rate: 0.0,
        });

        entry.execution_count += 1;
        entry.last_executed = Some(Utc::now());

        // Update rolling average response time
        entry.average_response_time_ms =
            (entry.average_response_time_ms * (entry.execution_count - 1) as f64 + response_time_ms)
            / entry.execution_count as f64;

        // Update error rate
        if !success {
            entry.error_rate = (entry.error_rate * (entry.execution_count - 1) as f64 + 1.0)
                / entry.execution_count as f64;
        } else {
            entry.error_rate = entry.error_rate * (entry.execution_count - 1) as f64
                / entry.execution_count as f64;
        }
    }

    // Update service health metrics
    pub async fn update_service_metrics(&self, service_name: &str, command_count: u64, error_count: u64) {
        let mut metrics = self.metrics.write().await;

        let health_status = if error_count > command_count / 2 {
            HealthStatus::Unhealthy
        } else if error_count > command_count / 10 {
            HealthStatus::Degraded
        } else {
            HealthStatus::Healthy
        };

        metrics.insert(service_name.to_string(), ServiceMetrics {
            service_name: service_name.to_string(),
            command_count,
            error_count,
            uptime_seconds: self.start_time.elapsed().as_secs(),
            last_activity: Some(Utc::now()),
            health_status,
        });
    }

    // Get comprehensive system overview
    pub async fn get_system_overview(&self) -> SystemOverview {
        let metrics = self.metrics.read().await;
        let command_stats = self.command_stats.read().await;

        let total_commands: u64 = metrics.values().map(|m| m.command_count).sum();
        let active_services: Vec<ServiceMetrics> = metrics.values().cloned().collect();
        let recent_commands: Vec<CommandStats> = command_stats.values()
            .cloned()
            .collect::<Vec<_>>()
            .into_iter()
            .take(10)
            .collect();

        let overall_health = if active_services.iter().any(|s| matches!(s.health_status, HealthStatus::Unhealthy)) {
            HealthStatus::Unhealthy
        } else if active_services.iter().any(|s| matches!(s.health_status, HealthStatus::Degraded)) {
            HealthStatus::Degraded
        } else {
            HealthStatus::Healthy
        };

        SystemOverview {
            total_commands,
            active_services,
            recent_commands,
            system_uptime: self.start_time.elapsed().as_secs(),
            overall_health,
        }
    }
}
```

### Step 4: Create Discord Bot Service

Create `src/discord.rs` for Discord bot functionality:

```rust
use crate::{models::*, state::AppState};
use poise::serenity_prelude as serenity;
use std::time::Instant;

pub type Error = Box<dyn std::error::Error + Send + Sync>;
pub type Context<'a> = poise::Context<'a, AppState, Error>;

/// Get comprehensive system statistics
#[poise::command(slash_command, description = "View detailed system statistics and health")]
pub async fn system_stats(ctx: Context<'_>) -> Result<(), Error> {
    let start_time = Instant::now();
    let app_state = ctx.data();

    let overview = app_state.get_system_overview().await;
    let response_time = start_time.elapsed().as_millis() as f64;

    // Record command execution
    app_state.record_command("system_stats", response_time, true).await;

    let health_emoji = match overview.overall_health {
        HealthStatus::Healthy => "üü¢",
        HealthStatus::Degraded => "üü°",
        HealthStatus::Unhealthy => "üî¥",
    };

    let response = format!(
        "{} **System Overview**\n\
        üìä Total Commands: {}\n\
        ‚è±Ô∏è System Uptime: {}s\n\
        üîß Active Services: {}\n\
        ‚ö° Response Time: {:.1}ms\n\n\
        **Recent Commands:**\n{}",
        health_emoji,
        overview.total_commands,
        overview.system_uptime,
        overview.active_services.len(),
        response_time,
        overview.recent_commands.iter()
            .take(5)
            .map(|cmd| format!(
                "‚Ä¢ `{}`: {} executions ({}ms avg)",
                cmd.command_name,
                cmd.execution_count,
                cmd.average_response_time_ms
            ))
            .collect::<Vec<_>>()
            .join("\n")
    );

    ctx.reply(response).await?;
    Ok(())
}

/// Execute a health check with diagnostics
#[poise::command(slash_command, description = "Perform comprehensive health check")]
pub async fn health_check(ctx: Context<'_>) -> Result<(), Error> {
    let start_time = Instant::now();
    let app_state = ctx.data();

    // Test database connectivity
    let db_health = match sqlx::query!("SELECT 1 as test").fetch_one(&app_state.pool).await {
        Ok(_) => "üü¢ Connected",
        Err(_) => "üî¥ Error",
    };

    let response_time = start_time.elapsed().as_millis() as f64;
    let success = db_health.contains("üü¢");

    app_state.record_command("health_check", response_time, success).await;

    let response = format!(
        "üè• **Health Check Results**\n\
        ü§ñ Bot Status: üü¢ Online\n\
        üóÑÔ∏è Database: {}\n\
        ‚ö° Response Time: {:.1}ms\n\
        üìà Memory Usage: {}MB\n\
        üïê Timestamp: {}",
        db_health,
        response_time,
        get_memory_usage(),
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    );

    ctx.reply(response).await?;
    Ok(())
}

/// Generate a performance report
#[poise::command(slash_command, description = "Generate detailed performance report")]
pub async fn performance_report(ctx: Context<'_>) -> Result<(), Error> {
    let start_time = Instant::now();
    let app_state = ctx.data();

    // Get database statistics
    let db_stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) as total_commands,
            AVG(response_time_ms) as avg_response_time,
            COUNT(*) FILTER (WHERE success = false) as error_count
        FROM command_logs
        WHERE created_at >= NOW() - INTERVAL '24 hours'
        "#
    )
    .fetch_one(&app_state.pool)
    .await?;

    let response_time = start_time.elapsed().as_millis() as f64;
    app_state.record_command("performance_report", response_time, true).await;

    let error_rate = if db_stats.total_commands.unwrap_or(0) > 0 {
        (db_stats.error_count.unwrap_or(0) as f64 / db_stats.total_commands.unwrap_or(1) as f64) * 100.0
    } else {
        0.0
    };

    let response = format!(
        "üìà **24-Hour Performance Report**\n\
        üî¢ Commands Executed: {}\n\
        ‚ö° Average Response Time: {:.1}ms\n\
        ‚ùå Error Rate: {:.1}%\n\
        üéØ Success Rate: {:.1}%\n\
        üîÑ Report Generated: {:.1}ms",
        db_stats.total_commands.unwrap_or(0),
        db_stats.avg_response_time.unwrap_or(0.0),
        error_rate,
        100.0 - error_rate,
        response_time
    );

    ctx.reply(response).await?;
    Ok(())
}

fn get_memory_usage() -> u64 {
    // Simplified memory usage (in production, use a proper system info crate)
    use std::alloc::{GlobalAlloc, Layout, System};
    42 // Placeholder - in real implementation, get actual memory usage
}

pub fn get_discord_commands() -> Vec<poise::Command<AppState, Error>> {
    vec![system_stats(), health_check(), performance_report()]
}
```

### Step 5: Create Web Dashboard Service

Create `src/web.rs` for the web interface:

```rust
use crate::{models::*, state::AppState};
use axum::{
    extract::State,
    http::StatusCode,
    response::{Html, Json},
    routing::get,
    Router,
};

pub fn create_web_router(state: AppState) -> Router {
    Router::new()
        .route("/", get(dashboard))
        .route("/api/overview", get(get_system_overview))
        .route("/api/metrics", get(get_metrics))
        .route("/api/health", get(health_endpoint))
        .with_state(state)
}

async fn dashboard() -> Html<&'static str> {
    Html(r#"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BotCommand Central - Multi-Service Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 3rem;
        }
        .header h1 { font-size: 3rem; margin-bottom: 0.5rem; }
        .header p { font-size: 1.2rem; opacity: 0.9; }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }
        .card {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }
        .card:hover { transform: translateY(-4px); }
        .card h3 {
            color: #667eea;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .metric:last-child { border-bottom: none; }
        .metric-label { font-weight: 500; }
        .metric-value {
            font-weight: bold;
            color: #667eea;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        .status-healthy { background: #4CAF50; }
        .status-degraded { background: #FF9800; }
        .status-unhealthy { background: #F44336; }

        .refresh-info {
            text-align: center;
            color: white;
            opacity: 0.8;
            margin-top: 2rem;
        }

        .command-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .command-item {
            padding: 0.75rem;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .command-name { font-family: monospace; background: #f8f9fa; padding: 0.25rem 0.5rem; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ BotCommand Central</h1>
            <p>Multi-Service Dashboard - Real-time Monitoring</p>
        </div>

        <div class="dashboard-grid">
            <div class="card">
                <h3>üìä System Overview</h3>
                <div id="systemOverview">
                    <div class="metric">
                        <span class="metric-label">Loading...</span>
                        <span class="metric-value">-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>‚ö° Performance Metrics</h3>
                <div id="performanceMetrics">
                    <div class="metric">
                        <span class="metric-label">Loading...</span>
                        <span class="metric-value">-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üîß Service Health</h3>
                <div id="serviceHealth">
                    <div class="metric">
                        <span class="metric-label">Loading...</span>
                        <span class="metric-value">-</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üìà Recent Commands</h3>
                <div class="command-list" id="recentCommands">
                    Loading commands...
                </div>
            </div>
        </div>

        <div class="refresh-info">
            <p>üîÑ Auto-refreshing every 5 seconds | Last updated: <span id="lastUpdate">-</span></p>
        </div>
    </div>

    <script>
        async function loadDashboardData() {
            try {
                const [overviewResponse, metricsResponse] = await Promise.all([
                    fetch('/api/overview'),
                    fetch('/api/metrics')
                ]);

                const overview = await overviewResponse.json();
                const metrics = await metricsResponse.json();

                updateSystemOverview(overview.data);
                updateServiceHealth(overview.data);
                updateRecentCommands(overview.data);

                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            } catch (error) {
                console.error('Failed to load dashboard data:', error);
            }
        }

        function updateSystemOverview(data) {
            const container = document.getElementById('systemOverview');
            container.innerHTML = `
                <div class="metric">
                    <span class="metric-label">Total Commands</span>
                    <span class="metric-value">${data.total_commands.toLocaleString()}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">System Uptime</span>
                    <span class="metric-value">${formatUptime(data.system_uptime)}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Active Services</span>
                    <span class="metric-value">${data.active_services.length}</span>
                </div>
            `;
        }

        function updateServiceHealth(data) {
            const container = document.getElementById('serviceHealth');
            const healthHTML = data.active_services.map(service => `
                <div class="metric">
                    <span class="metric-label">
                        <span class="status-indicator status-${service.health_status.toLowerCase()}"></span>
                        ${service.service_name}
                    </span>
                    <span class="metric-value">${service.command_count} cmds</span>
                </div>
            `).join('');

            container.innerHTML = healthHTML || '<div class="metric"><span>No services active</span></div>';
        }

        function updateRecentCommands(data) {
            const container = document.getElementById('recentCommands');
            const commandsHTML = data.recent_commands.map(cmd => `
                <div class="command-item">
                    <span class="command-name">${cmd.command_name}</span>
                    <span>${cmd.execution_count}x (${cmd.average_response_time_ms.toFixed(1)}ms)</span>
                </div>
            `).join('');

            container.innerHTML = commandsHTML || '<div class="command-item">No commands executed yet</div>';
        }

        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours}h ${minutes}m`;
        }

        // Load data immediately and set up auto-refresh
        loadDashboardData();
        setInterval(loadDashboardData, 5000);
    </script>
</body>
</html>
    "#)
}

async fn get_system_overview(State(state): State<AppState>) -> Json<ApiResponse<SystemOverview>> {
    let overview = state.get_system_overview().await;
    Json(ApiResponse::success(overview))
}

async fn get_metrics(State(state): State<AppState>) -> Json<ApiResponse<Vec<ServiceMetrics>>> {
    let metrics = state.metrics.read().await;
    let metrics_vec: Vec<ServiceMetrics> = metrics.values().cloned().collect();
    Json(ApiResponse::success(metrics_vec))
}

async fn health_endpoint() -> Json<ApiResponse<serde_json::Value>> {
    Json(ApiResponse::success(serde_json::json!({
        "status": "healthy",
        "service": "botcommand-central",
        "timestamp": chrono::Utc::now(),
        "version": "1.0.0"
    })))
}
```

### Step 6: Implement Custom Service with Infrastructure from Code

Create `src/service.rs` for the custom service implementation:

```rust
use crate::{discord, state::AppState, web};
use poise::serenity_prelude as serenity;
use shuttle_runtime::{Error as ShuttleError, Service};
use std::net::SocketAddr;
use tokio::time::{interval, Duration};

pub struct MultiServiceApp {
    pub discord_token: String,
    pub state: AppState,
}

#[shuttle_runtime::async_trait]
impl Service for MultiServiceApp {
    async fn bind(self, addr: SocketAddr) -> Result<(), ShuttleError> {
        tracing::info!("üöÄ Starting BotCommand Central Multi-Service Application");

        // Initialize Discord bot framework
        let framework = poise::Framework::builder()
            .options(poise::FrameworkOptions {
                commands: discord::get_discord_commands(),
                prefix_options: poise::PrefixFrameworkOptions {
                    prefix: Some("!".into()),
                    ..Default::default()
                },
                // Add error handler for better reliability
                on_error: |error| {
                    Box::pin(async move {
                        tracing::error!("Discord command error: {:?}", error);
                    })
                },
                ..Default::default()
            })
            .setup(|ctx, _ready, framework| {
                Box::pin(async move {
                    tracing::info!("ü§ñ Registering Discord slash commands...");
                    poise::builtins::register_globally(ctx, &framework.options().commands).await?;
                    tracing::info!("‚úÖ Discord bot commands registered successfully");
                    Ok(self.state.clone())
                })
            })
            .build();

        // Create Discord client
        let client = serenity::ClientBuilder::new(
            &self.discord_token,
            serenity::GatewayIntents::non_privileged() | serenity::GatewayIntents::MESSAGE_CONTENT,
        )
        .framework(framework)
        .await
        .map_err(|e| ShuttleError::Custom(e.into()))?;

        // Create web server
        let app = web::create_web_router(self.state.clone());
        let listener = tokio::net::TcpListener::bind(addr)
            .await
            .map_err(|e| ShuttleError::Custom(e.into()))?;

        // Background metrics collection task
        let state_for_metrics = self.state.clone();
        let metrics_task = tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(30));
            loop {
                interval.tick().await;

                // Update service metrics periodically
                let command_stats = state_for_metrics.command_stats.read().await;
                let total_commands: u64 = command_stats.values().map(|c| c.execution_count).sum();
                let error_count: u64 = command_stats.values()
                    .map(|c| (c.error_rate * c.execution_count as f64) as u64)
                    .sum();

                state_for_metrics.update_service_metrics("discord-bot", total_commands, error_count).await;
                state_for_metrics.update_service_metrics("web-dashboard", 1, 0).await;

                tracing::debug!("üìä Updated service metrics: {} commands, {} errors", total_commands, error_count);
            }
        });

        tracing::info!("üåê Web dashboard available at: http://{}", addr);
        tracing::info!("ü§ñ Discord bot connecting...");
        tracing::info!("üìä Background metrics collection started");

        // Run all services concurrently with proper error handling
        let result = tokio::select! {
            result = axum::serve(listener, app) => {
                tracing::error!("‚ùå Web server stopped: {:?}", result);
                result.map_err(|e| ShuttleError::Custom(e.into()))
            }
            result = client.start() => {
                tracing::error!("‚ùå Discord bot stopped: {:?}", result);
                result.map_err(|e| ShuttleError::Custom(e.into()))
            }
            result = metrics_task => {
                tracing::error!("‚ùå Metrics collection stopped: {:?}", result);
                result.map_err(|e| ShuttleError::Custom(e.into()))?;
                Ok(())
            }
        };

        result
    }
}
```

### Step 7: Initialize Database Schema

Create `src/database.rs` for Infrastructure from Code database setup:

```rust
use sqlx::PgPool;

pub async fn initialize_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    // Create command logs table with optimized indexes
    sqlx::query!(
        r#"
        CREATE TABLE IF NOT EXISTS command_logs (
            id SERIAL PRIMARY KEY,
            command_name VARCHAR(100) NOT NULL,
            execution_time TIMESTAMPTZ NOT NULL,
            response_time_ms REAL NOT NULL,
            success BOOLEAN NOT NULL DEFAULT true,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            user_id VARCHAR(100),
            guild_id VARCHAR(100)
        );

        -- Indexes for performance analytics
        CREATE INDEX IF NOT EXISTS idx_command_logs_command_name ON command_logs(command_name);
        CREATE INDEX IF NOT EXISTS idx_command_logs_created_at ON command_logs(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_command_logs_success ON command_logs(success);
        CREATE INDEX IF NOT EXISTS idx_command_logs_performance ON command_logs(command_name, created_at DESC, response_time_ms);

        -- Service health monitoring table
        CREATE TABLE IF NOT EXISTS service_health (
            service_name VARCHAR(100) PRIMARY KEY,
            last_heartbeat TIMESTAMPTZ DEFAULT NOW(),
            status VARCHAR(20) DEFAULT 'healthy',
            error_count INTEGER DEFAULT 0,
            total_requests INTEGER DEFAULT 0,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- Create or update trigger for updating timestamps
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $$ language 'plpgsql';

        DROP TRIGGER IF EXISTS update_service_health_updated_at ON service_health;
        CREATE TRIGGER update_service_health_updated_at
            BEFORE UPDATE ON service_health
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        "#
    )
    .execute(pool)
    .await?;

    tracing::info!("‚úÖ Database schema initialized successfully");
    Ok(())
}

pub async fn check_database_health(pool: &PgPool) -> Result<serde_json::Value, sqlx::Error> {
    let stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) as total_commands,
            COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '1 hour') as commands_last_hour,
            COUNT(*) FILTER (WHERE success = false) as total_errors,
            AVG(response_time_ms) as avg_response_time
        FROM command_logs
        "#
    )
    .fetch_one(pool)
    .await?;

    Ok(serde_json::json!({
        "database_status": "connected",
        "total_commands": stats.total_commands,
        "commands_last_hour": stats.commands_last_hour,
        "total_errors": stats.total_errors,
        "average_response_time_ms": stats.avg_response_time
    }))
}
```

### Step 8: Wire Everything Together

Update `src/main.rs` to create the complete multi-service application:

```rust
mod models;
mod state;
mod discord;
mod web;
mod service;
mod database;

use anyhow::Context;
use service::MultiServiceApp;
use shuttle_runtime::SecretStore;
use sqlx::PgPool;
use state::AppState;

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] pool: PgPool,
    #[shuttle_secrets::Secrets] secrets: SecretStore,
) -> Result<MultiServiceApp, shuttle_runtime::Error> {
    // Initialize structured logging
    tracing_subscriber::fmt()
        .with_target(false)
        .with_thread_ids(true)
        .init();

    tracing::info!("üöÄ Initializing BotCommand Central Multi-Service Application");

    // Initialize database schema using Infrastructure from Code
    database::initialize_database(&pool)
        .await
        .context("Failed to initialize database schema")?;

    // Get Discord bot token from secrets
    let discord_token = secrets
        .get("DISCORD_TOKEN")
        .context("DISCORD_TOKEN secret not found - add it to Secrets.toml")?;

    // Create shared application state
    let state = AppState::new(pool);

    tracing::info!("‚úÖ Application state initialized");
    tracing::info!("üóÑÔ∏è Database schema ready");
    tracing::info!("üîê Secrets loaded successfully");

    Ok(MultiServiceApp {
        discord_token,
        state,
    })
}
```

### Step 9: Configure Secrets and Deploy

Create `Secrets.toml` with your Discord bot configuration:

```toml
DISCORD_TOKEN = "your_discord_bot_token_here"
```

Deploy your multi-service application:

```bash
shuttle deploy
```

### Step 10: Test Your Multi-Service Application

Test the complete system:

**Discord Bot Commands:**

- `/system_stats` - View comprehensive system metrics
- `/health_check` - Perform health diagnostics
- `/performance_report` - Generate 24-hour performance report

**Web Dashboard:**

- Visit your deployed URL to see the real-time dashboard
- Monitor command executions, service health, and performance metrics
- Watch metrics update automatically every 5 seconds

**API Endpoints:**

```bash
# Replace with your deployed URL
export BASE_URL="https://botcommand-central.shuttle.app"

curl "$BASE_URL/api/overview"
curl "$BASE_URL/api/metrics"
curl "$BASE_URL/api/health"
```

## What You've Learned

You've successfully built a sophisticated multi-service application and mastered:

### Shuttle Multi-Service Patterns

- **Custom Service Implementation** with the `Service` trait
- **Shared Resource Management** across multiple service types
- **Infrastructure from Code** for database schemas and migrations
- **Concurrent Service Orchestration** with error handling

### Advanced Runtime Architecture

- **Service composition** combining Discord bots, web APIs, and background tasks
- **Cross-service state management** with thread-safe data structures
- **Real-time metrics collection** and health monitoring
- **Graceful error handling** and service recovery

### Production Multi-Service Design

- **Structured logging** across all services
- **Performance monitoring** with response time tracking
- **Health checks** and system diagnostics
- **Auto-recovery patterns** for service resilience

## Troubleshooting

**Services not starting together?**

- Check that the custom `Service` trait implementation is correct
- Verify all dependencies are properly initialized before service startup
- Ensure database connections are established before Discord bot connects

**Shared state not updating?**

- Confirm that `Arc<RwLock<>>` patterns are used consistently
- Check that async/await is properly used when accessing shared state
- Verify that all services are using the same `AppState` instance

**Discord bot or web server failing?**

- Check logs with `shuttle logs` for specific error messages
- Verify Discord token is valid and has proper permissions
- Ensure port binding and routing are configured correctly

**Database migrations failing?**

- Check that PostgreSQL connection is successful
- Verify SQL syntax in migration scripts
- Ensure database permissions allow table creation

## Next Steps

Expand your multi-service application with:

1. **WebSocket Integration** - Add real-time web notifications ([WebSocket Tutorial](/tutorials/intermediate/websocket-chat-app-js))
2. **Scheduled Tasks** - Add cron jobs and periodic maintenance
3. **External API Integration** - Connect to third-party services and APIs
4. **Load Balancing** - Scale services horizontally with multiple instances
5. **Monitoring & Alerting** - Add comprehensive observability ([Datadog Tutorial](/tutorials/advanced/send-your-logs-to-datadog))

Your multi-service application demonstrates the power of Shuttle's custom service capabilities for building complex, production-ready systems!

## Complete Code

Find the complete working code for this tutorial in our [examples repository](https://github.com/shuttle-hq/shuttle-examples/tree/main/multi-service).
