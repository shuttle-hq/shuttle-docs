---
title: "Building a URL Shortener Service"
description: "Learn to build a complete URL shortening service with custom domains and analytics"
icon: "link"
---

> This tutorial is based on the original creative work by [Terrence](https://github.com/shuttle-hq), adapted into a structured learning format.

## Learning Objectives

By the end of this tutorial, you will have built a **Production URL Shortener** and learned how to:

- Create RESTful APIs that handle URL validation and storage
- Generate unique short IDs using nanoid for collision-resistant identifiers
- Build database schemas with proper indexing for fast lookups
- Handle HTTP redirects and status codes correctly
- Implement URL validation and error handling
- Deploy services with custom domains and analytics tracking

## Prerequisites

- Completed [Your First Shuttle App](/tutorials/your-first-app) tutorial
- Basic HTTP knowledge (GET, POST, redirects)
- Understanding of databases and primary keys
- [Shuttle CLI installed](/getting-started/installation)

**Time Required**: 30-45 minutes

## What We're Building

We'll create a **URL Shortener Service** that provides:

- **URL shortening API** - Convert long URLs to short codes
- **Redirect service** - Automatically redirect short URLs to original destinations
- **URL validation** - Ensure submitted URLs are valid and accessible
- **Custom short codes** - Generate unique, collision-resistant identifiers
- **Analytics tracking** - Count clicks and track usage statistics
- **Error handling** - Proper HTTP status codes and error messages

Users will be able to shorten URLs via API and share the short links that automatically redirect to the original destinations.

## Step 1: Create Your Project

Start with a Rocket web framework project:

```bash
shuttle init --template rocket url-shortener
cd url-shortener
```

Examine the generated structure:

```bash
cat src/main.rs
```

You should see:

```rust
#[macro_use]
extern crate rocket;

#[get("/")]
fn index() -> &'static str {
    "Hello, world!"
}

#[shuttle_runtime::main]
async fn rocket() -> shuttle_rocket::ShuttleRocket {
    let rocket = rocket::build().mount("/", routes![index]);
    Ok(rocket.into())
}
```

Test the basic setup:

```bash
shuttle run
```

Visit `http://localhost:8000` to see "Hello, world!". Press `Ctrl+C` to stop.

**What to notice**: The Rocket template provides a working web server that we'll extend with URL shortening functionality.

## Step 2: Add Database Support

Update your `Cargo.toml` to include database dependencies:

```toml
[package]
name = "url-shortener"
version = "0.1.0"
edition = "2021"

[dependencies]
rocket = { version = "0.5.0", features = ["json"] }
shuttle-rocket = "0.56.0"
shuttle-runtime = "0.56.0"
shuttle-shared-db = "0.56.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "macros", "chrono"] }
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["macros"] }
nanoid = "0.4"
url = "2.4"
chrono = { version = "0.4", features = ["serde"] }
```

Update `src/main.rs` to add database connection:

```rust
#[macro_use]
extern crate rocket;

use rocket::State;
use sqlx::PgPool;

#[get("/")]
fn index() -> &'static str {
    "URL Shortener Service - API available at POST / and GET /<id>"
}

#[shuttle_runtime::main]
async fn rocket(#[shuttle_shared_db::Postgres] pool: PgPool) -> shuttle_rocket::ShuttleRocket {
    // Run database migrations
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS urls (
            id VARCHAR(6) PRIMARY KEY,
            url VARCHAR NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            click_count INTEGER DEFAULT 0
        );

        CREATE INDEX IF NOT EXISTS idx_urls_created_at ON urls(created_at);
        "#
    )
    .execute(&pool)
    .await
    .expect("Failed to run database migrations");

    let rocket = rocket::build()
        .mount("/", routes![index])
        .manage(pool);

    Ok(rocket.into())
}
```

Test the database setup:

```bash
cargo build
shuttle run
```

You should see the migration run successfully and the server start.

**What to notice**: Shuttle automatically provisions a PostgreSQL database and runs our schema migration on startup.

## Step 3: Create Data Models

Create `src/models.rs` for our data structures:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct ShortenRequest {
    pub url: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ShortenResponse {
    pub short_url: String,
    pub original_url: String,
    pub short_id: String,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UrlRecord {
    pub id: String,
    pub url: String,
    pub created_at: DateTime<Utc>,
    pub click_count: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

impl ErrorResponse {
    pub fn new(error: &str, message: &str) -> Self {
        Self {
            error: error.to_string(),
            message: message.to_string(),
        }
    }
}
```

Add the module to `src/main.rs`:

```rust
mod models;

use models::*;
```

**What to notice**: We define clear request/response types and include metadata like creation time and click counting for analytics.

## Step 4: Build URL Shortening Logic

Create `src/shortener.rs` for the core URL shortening functionality:

```rust
use crate::models::*;
use sqlx::PgPool;
use url::Url;
use nanoid::nanoid;
use chrono::Utc;

pub struct UrlShortener {
    pool: PgPool,
    base_url: String,
}

impl UrlShortener {
    pub fn new(pool: PgPool, base_url: String) -> Self {
        Self { pool, base_url }
    }

    pub async fn shorten_url(&self, url_str: &str) -> Result<ShortenResponse, String> {
        // Validate URL format
        let parsed_url = Url::parse(url_str)
            .map_err(|_| "Invalid URL format".to_string())?;

        // Ensure it's HTTP or HTTPS
        if !matches!(parsed_url.scheme(), "http" | "https") {
            return Err("URL must use HTTP or HTTPS protocol".to_string());
        }

        // Generate unique short ID (with retry logic for collisions)
        let short_id = self.generate_unique_id().await?;

        // Store in database
        let created_at = Utc::now();
        sqlx::query!(
            "INSERT INTO urls (id, url, created_at) VALUES ($1, $2, $3)",
            short_id,
            parsed_url.as_str(),
            created_at
        )
        .execute(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?;

        Ok(ShortenResponse {
            short_url: format!("{}/{}", self.base_url, short_id),
            original_url: parsed_url.as_str().to_string(),
            short_id: short_id.clone(),
            created_at,
        })
    }

    pub async fn get_original_url(&self, short_id: &str) -> Result<String, String> {
        // Validate short_id format (should be 6 characters)
        if short_id.len() != 6 {
            return Err("Invalid short ID format".to_string());
        }

        // Get URL and increment click count
        let result = sqlx::query!(
            r#"
            UPDATE urls
            SET click_count = click_count + 1
            WHERE id = $1
            RETURNING url
            "#,
            short_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?;

        match result {
            Some(record) => Ok(record.url),
            None => Err("Short URL not found".to_string()),
        }
    }

    pub async fn get_stats(&self, short_id: &str) -> Result<UrlRecord, String> {
        let result = sqlx::query_as!(
            UrlRecord,
            "SELECT id, url, created_at, click_count FROM urls WHERE id = $1",
            short_id
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| format!("Database error: {}", e))?;

        match result {
            Some(record) => Ok(record),
            None => Err("Short URL not found".to_string()),
        }
    }

    async fn generate_unique_id(&self) -> Result<String, String> {
        for _ in 0..10 {  // Try up to 10 times
            let id = nanoid!(6);

            // Check if ID already exists
            let exists = sqlx::query!("SELECT 1 FROM urls WHERE id = $1", id)
                .fetch_optional(&self.pool)
                .await
                .map_err(|e| format!("Database error: {}", e))?;

            if exists.is_none() {
                return Ok(id);
            }
        }

        Err("Failed to generate unique ID after multiple attempts".to_string())
    }
}
```

Add the module to `src/main.rs`:

```rust
mod shortener;

use shortener::UrlShortener;
```

**What to notice**: We include URL validation, collision handling for ID generation, and automatic click tracking with database updates.

## Step 5: Create API Endpoints

Create `src/handlers.rs` for HTTP route handlers:

```rust
use crate::{models::*, shortener::UrlShortener};
use rocket::{serde::json::Json, response::Redirect, State, http::Status};

#[post("/", data = "<request>")]
pub async fn shorten_url(
    request: Json<ShortenRequest>,
    shortener: &State<UrlShortener>,
) -> Result<Json<ShortenResponse>, (Status, Json<ErrorResponse>)> {
    match shortener.shorten_url(&request.url).await {
        Ok(response) => Ok(Json(response)),
        Err(error) => Err((
            Status::BadRequest,
            Json(ErrorResponse::new("invalid_url", &error))
        )),
    }
}

#[get("/<short_id>")]
pub async fn redirect_url(
    short_id: &str,
    shortener: &State<UrlShortener>,
) -> Result<Redirect, (Status, Json<ErrorResponse>)> {
    match shortener.get_original_url(short_id).await {
        Ok(original_url) => Ok(Redirect::permanent(original_url)),
        Err(error) => Err((
            Status::NotFound,
            Json(ErrorResponse::new("not_found", &error))
        )),
    }
}

#[get("/stats/<short_id>")]
pub async fn get_stats(
    short_id: &str,
    shortener: &State<UrlShortener>,
) -> Result<Json<UrlRecord>, (Status, Json<ErrorResponse>)> {
    match shortener.get_stats(short_id).await {
        Ok(stats) => Ok(Json(stats)),
        Err(error) => Err((
            Status::NotFound,
            Json(ErrorResponse::new("not_found", &error))
        )),
    }
}

// URL shortening via form data (for browser compatibility)
#[post("/", data = "<url>", rank = 2)]
pub async fn shorten_url_form(
    url: String,
    shortener: &State<UrlShortener>,
) -> Result<String, (Status, String)> {
    match shortener.shorten_url(&url).await {
        Ok(response) => Ok(response.short_url),
        Err(error) => Err((Status::BadRequest, error)),
    }
}
```

Update `src/main.rs` to wire up the handlers:

```rust
mod models;
mod shortener;
mod handlers;

use models::*;
use shortener::UrlShortener;
use handlers::*;

#[macro_use]
extern crate rocket;

use rocket::State;
use sqlx::PgPool;

#[get("/")]
fn index() -> &'static str {
    r#"
    URL Shortener Service

    API Endpoints:
    POST /          - Shorten a URL (JSON: {"url": "https://example.com"})
    GET /<id>       - Redirect to original URL
    GET /stats/<id> - Get URL statistics

    Example:
    curl -X POST -H "Content-Type: application/json" \
         -d '{"url":"https://example.com"}' \
         http://localhost:8000

    Or send URL as plain text:
    curl -X POST -d 'https://example.com' http://localhost:8000
    "#
}

#[shuttle_runtime::main]
async fn rocket(#[shuttle_shared_db::Postgres] pool: PgPool) -> shuttle_rocket::ShuttleRocket {
    // Run database migrations
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS urls (
            id VARCHAR(6) PRIMARY KEY,
            url VARCHAR NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            click_count INTEGER DEFAULT 0
        );

        CREATE INDEX IF NOT EXISTS idx_urls_created_at ON urls(created_at);
        "#
    )
    .execute(&pool)
    .await
    .expect("Failed to run database migrations");

    // Create URL shortener service
    let base_url = std::env::var("BASE_URL")
        .unwrap_or_else(|_| "http://localhost:8000".to_string());
    let shortener = UrlShortener::new(pool, base_url);

    let rocket = rocket::build()
        .mount("/", routes![
            index,
            shorten_url,
            shorten_url_form,
            redirect_url,
            get_stats
        ])
        .manage(shortener);

    Ok(rocket.into())
}
```

Build and test the complete API:

```bash
cargo build
shuttle run
```

**What to notice**: We support both JSON API requests and simple form data, plus provide statistics endpoints for analytics.

## Step 6: Test Your URL Shortener

With your server running (`shuttle run`), test the API endpoints:

**Shorten a URL using JSON:**

```bash
curl -X POST -H "Content-Type: application/json" \
     -d '{"url":"https://www.rust-lang.org"}' \
     http://localhost:8000
```

Expected response:

```json
{
  "short_url": "http://localhost:8000/abc123",
  "original_url": "https://www.rust-lang.org",
  "short_id": "abc123",
  "created_at": "2024-01-15T10:30:00Z"
}
```

**Shorten a URL using plain text:**

```bash
curl -X POST -d 'https://github.com' http://localhost:8000
```

**Test the redirect:**

```bash
curl -I http://localhost:8000/abc123
```

You should see a `301 Moved Permanently` response with the `Location` header pointing to the original URL.

**Get statistics:**

```bash
curl http://localhost:8000/stats/abc123
```

Expected response:

```json
{
  "id": "abc123",
  "url": "https://www.rust-lang.org",
  "created_at": "2024-01-15T10:30:00Z",
  "click_count": 1
}
```

**Test error handling:**

```bash
# Invalid URL
curl -X POST -H "Content-Type: application/json" \
     -d '{"url":"not-a-valid-url"}' \
     http://localhost:8000

# Non-existent short ID
curl http://localhost:8000/nonexistent
```

**What to notice**: The service validates URLs, generates unique IDs, tracks clicks, and handles errors gracefully with appropriate HTTP status codes.

## Step 7: Add Advanced Features

Create `src/analytics.rs` for enhanced analytics:

```rust
use crate::models::*;
use sqlx::PgPool;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct AnalyticsResponse {
    pub total_urls: i64,
    pub total_clicks: i64,
    pub recent_urls: Vec<UrlRecord>,
    pub top_urls: Vec<UrlRecord>,
}

pub async fn get_analytics(pool: &PgPool) -> Result<AnalyticsResponse, String> {
    // Get total counts
    let totals = sqlx::query!(
        "SELECT COUNT(*) as url_count, COALESCE(SUM(click_count), 0) as total_clicks FROM urls"
    )
    .fetch_one(pool)
    .await
    .map_err(|e| format!("Database error: {}", e))?;

    // Get recent URLs (last 10)
    let recent_urls = sqlx::query_as!(
        UrlRecord,
        "SELECT id, url, created_at, click_count FROM urls ORDER BY created_at DESC LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| format!("Database error: {}", e))?;

    // Get top URLs by clicks (top 10)
    let top_urls = sqlx::query_as!(
        UrlRecord,
        "SELECT id, url, created_at, click_count FROM urls ORDER BY click_count DESC, created_at DESC LIMIT 10"
    )
    .fetch_all(pool)
    .await
    .map_err(|e| format!("Database error: {}", e))?;

    Ok(AnalyticsResponse {
        total_urls: totals.url_count.unwrap_or(0),
        total_clicks: totals.total_clicks.unwrap_or(0),
        recent_urls,
        top_urls,
    })
}
```

Add an analytics endpoint to `src/handlers.rs`:

```rust
use crate::analytics;

#[get("/analytics")]
pub async fn get_analytics_endpoint(
    pool: &State<PgPool>,
) -> Result<Json<AnalyticsResponse>, (Status, Json<ErrorResponse>)> {
    match analytics::get_analytics(pool).await {
        Ok(analytics) => Ok(Json(analytics)),
        Err(error) => Err((
            Status::InternalServerError,
            Json(ErrorResponse::new("server_error", &error))
        )),
    }
}
```

Update `src/main.rs` to include the new modules and route:

```rust
mod analytics;

// Add to routes
.mount("/", routes![
    index,
    shorten_url,
    shorten_url_form,
    redirect_url,
    get_stats,
    get_analytics_endpoint
])
.manage(shortener)
.manage(pool.clone());  // Also manage the pool directly for analytics
```

Test the analytics endpoint:

```bash
curl http://localhost:8000/analytics
```

**What to notice**: Analytics provide insights into service usage, popular URLs, and overall statistics for business intelligence.

## Step 8: Deploy to Production

Set up environment variables for production by creating `Secrets.toml`:

```toml
BASE_URL = "https://your-app-name.shuttle.app"
```

Deploy your URL shortener:

```bash
shuttle deploy
```

After deployment, test your live service:

```bash
# Replace with your actual Shuttle URL
export BASE_URL="https://your-app-name.shuttle.app"

# Test URL shortening
curl -X POST -H "Content-Type: application/json" \
     -d '{"url":"https://www.rust-lang.org"}' \
     $BASE_URL

# Test the redirect in a browser or with curl
curl -I $BASE_URL/abc123

# Check analytics
curl $BASE_URL/analytics
```

**What to notice**: Your URL shortener is now live on the internet with a custom domain, ready to handle real traffic.

## Step 9: Advanced Testing and Validation

Create `src/validation.rs` for enhanced URL validation:

```rust
use url::Url;
use std::collections::HashSet;

pub struct UrlValidator {
    blocked_domains: HashSet<String>,
    allowed_schemes: HashSet<String>,
}

impl UrlValidator {
    pub fn new() -> Self {
        let mut blocked_domains = HashSet::new();
        blocked_domains.insert("localhost".to_string());
        blocked_domains.insert("127.0.0.1".to_string());
        blocked_domains.insert("0.0.0.0".to_string());

        let mut allowed_schemes = HashSet::new();
        allowed_schemes.insert("http".to_string());
        allowed_schemes.insert("https".to_string());

        Self {
            blocked_domains,
            allowed_schemes,
        }
    }

    pub fn validate_url(&self, url_str: &str) -> Result<Url, String> {
        // Parse URL
        let url = Url::parse(url_str)
            .map_err(|_| "Invalid URL format".to_string())?;

        // Check scheme
        if !self.allowed_schemes.contains(url.scheme()) {
            return Err("URL must use HTTP or HTTPS".to_string());
        }

        // Check for blocked domains
        if let Some(domain) = url.domain() {
            if self.blocked_domains.contains(domain) {
                return Err("Domain not allowed".to_string());
            }
        }

        // Check for valid domain
        if url.domain().is_none() {
            return Err("URL must have a valid domain".to_string());
        }

        Ok(url)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_urls() {
        let validator = UrlValidator::new();

        assert!(validator.validate_url("https://example.com").is_ok());
        assert!(validator.validate_url("http://github.com/user/repo").is_ok());
        assert!(validator.validate_url("https://subdomain.example.org/path?query=value").is_ok());
    }

    #[test]
    fn test_invalid_urls() {
        let validator = UrlValidator::new();

        assert!(validator.validate_url("not-a-url").is_err());
        assert!(validator.validate_url("ftp://example.com").is_err());
        assert!(validator.validate_url("http://localhost").is_err());
        assert!(validator.validate_url("https://127.0.0.1").is_err());
    }
}
```

Run the tests:

```bash
cargo test
```

**What to notice**: Proper validation prevents security issues and ensures only legitimate URLs are shortened.

## Step 10: Load Testing and Performance

Test your deployed service with multiple URLs to verify it handles concurrent requests:

```bash
# Create a test script
cat > test_load.sh << 'EOF'
#!/bin/bash
BASE_URL="https://your-app-name.shuttle.app"

# Array of test URLs
urls=(
    "https://www.rust-lang.org"
    "https://github.com"
    "https://docs.rs"
    "https://crates.io"
    "https://www.mozilla.org"
)

echo "Testing URL shortening service..."

for url in "${urls[@]}"; do
    echo "Shortening: $url"
    result=$(curl -s -X POST -H "Content-Type: application/json" \
                  -d "{\"url\":\"$url\"}" \
                  $BASE_URL)
    echo "Result: $result"
    echo "---"
done

echo "Checking analytics..."
curl -s $BASE_URL/analytics | jq .

echo "Testing complete!"
EOF

chmod +x test_load.sh
./test_load.sh
```

**What to notice**: The service should handle multiple concurrent requests efficiently and maintain accurate click counts and analytics.

## What You've Accomplished

Congratulations! You've built a production-ready URL shortener with:

- ✅ **RESTful API** with JSON and form data support
- ✅ **URL validation** with security checks and domain filtering
- ✅ **Unique ID generation** with collision handling using nanoid
- ✅ **Database storage** with optimized indexes and migrations
- ✅ **HTTP redirects** with proper status codes (301 Permanent)
- ✅ **Click analytics** with real-time tracking and statistics
- ✅ **Error handling** with appropriate HTTP status codes and messages
- ✅ **Production deployment** with custom domain support

## Key Concepts You've Learned

### URL Shortening Algorithm

Generating collision-resistant short identifiers:

```rust
let short_id = nanoid!(6);  // Generates URL-safe 6-character ID
// Check for collisions and retry if needed
```

### HTTP Redirects

Implementing proper redirect responses:

```rust
Ok(Redirect::permanent(original_url))  // 301 Permanent Redirect
```

### Database Optimization

Using indexes for fast lookups:

```sql
CREATE INDEX IF NOT EXISTS idx_urls_created_at ON urls(created_at);
```

### Analytics Tracking

Atomic click counting with database updates:

```rust
UPDATE urls SET click_count = click_count + 1 WHERE id = $1
```

## Next Steps

Now that you understand URL shortening services, you can:

1. **Add custom domains** - Allow users to use their own domains
2. **Implement user accounts** - Track URLs per user with authentication
3. **Add expiration dates** - Support temporary short URLs
4. **Create a web dashboard** - Build a frontend for managing URLs
5. **Add QR code generation** - Generate QR codes for shortened URLs
6. **Implement rate limiting** - Prevent abuse with request throttling

Try our [Authentication tutorial](/tutorials/authentication) to add user management!

## Troubleshooting

**Database connection errors?**

- Ensure your database migrations ran successfully
- Check that the database schema matches your queries
- Verify that connection pooling is working properly

**Short ID collisions?**

- The nanoid library generates cryptographically secure random IDs
- Our retry logic handles the rare case of collisions
- Consider increasing ID length if collision rates are high

**URL validation failing?**

- Check that URLs include the protocol (http:// or https://)
- Verify the URL format is valid according to RFC standards
- Ensure domains are not in the blocked list

**Redirects not working?**

- Verify the original URL is stored correctly in the database
- Check that the redirect endpoint returns a 301 status code
- Ensure the Location header contains the full URL

**Analytics not updating?**

- Check that database transactions are committed properly
- Verify that the UPDATE query is executing successfully
- Ensure click counting happens before the redirect

**Production deployment issues?**

- Verify the BASE_URL environment variable is set correctly
- Check that the database is accessible from the deployed service
- Ensure all routes are properly mounted and accessible

You've successfully learned how to build scalable web services with database persistence and analytics!
