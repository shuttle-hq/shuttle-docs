---
title: "Real-Time Chat with Shuttle WebSockets"
description: "Learn to build real-time applications using Shuttle's WebSocket support and static file serving"
icon: "plug"
---

## Learning Objectives

By the end of this tutorial, you will understand these **Shuttle real-time concepts**:

- **WebSocket Integration** - Real-time communication with Shuttle + Axum
- **Static File Serving** - Frontend delivery through Shuttle's built-in static hosting
- **State Management** - Managing connected users and message broadcasting
- **Concurrent Connections** - Handling multiple WebSocket connections efficiently
- **Frontend integration** - Connecting React/JavaScript clients to Shuttle WebSocket APIs

You'll build a **Real-Time Chat Application** that demonstrates Shuttle's full-stack capabilities for interactive applications.

## Prerequisites

- **Time Required**: 30 minutes
- **Rust Version**: 1.75.0 or higher with Cargo
- **Experience Level**: Completed [User Authentication](/tutorials/intermediate/authentication)
- **WebSocket Knowledge**: Basic understanding of real-time communication concepts
- **Frontend Knowledge**: Basic HTML/JavaScript (React knowledge helpful but not required)
- **Tools Required**: [Shuttle CLI](/getting-started/installation) and web browser
- **Accounts Needed**: [Shuttle account](https://shuttle.rs) (free tier available)

## What We're Building

A **Real-Time Chat Application** with WebSocket communication, demonstrating Shuttle's full-stack capabilities for interactive real-time applications with static file serving.

This tutorial shows production-ready real-time patterns: WebSocket connection management, message broadcasting, user presence tracking, chat persistence, and frontend integration served through Shuttle's static folder.

### High-Level Components

- **WebSocket Server** - Real-time bidirectional communication with connection lifecycle management
- **Static File Serving** - Frontend React app delivered by Shuttle's built-in static hosting
- **Message Broadcasting** - Real-time message delivery to connected users in chat rooms
- **PostgreSQL Integration** - Chat history persistence and user management
- **Connection State Management** - In-memory tracking of active users and room presence
- **Frontend Client** - React-based chat interface with WebSocket integration

## Step 1: Initialize Real-Time Shuttle Project

**Shuttle Concept**: Shuttle provides first-class WebSocket support with automatic connection management and static file serving for complete full-stack applications.

Create your real-time chat project:

```bash
# Create new Shuttle project optimized for real-time features
cargo shuttle init chat-app

# Select "Axum" when prompted
cd chat-app
```

Update `Cargo.toml` for WebSocket and frontend support:

```toml
[package]
name = "chat-app"
version = "0.1.0"
edition = "2021"

[dependencies]
# Shuttle core with database and static files
axum = { version = "0.8", features = ["ws", "macros"] }
shuttle-axum = "0.56.0"
shuttle-runtime = "0.56.0"
shuttle-shared-db = "0.56.0"
shuttle-static-folder = "0.56.0"

# WebSocket and real-time support
tokio = { version = "1.0", features = ["full"] }
tokio-tungstenite = "0.21"
futures-util = { version = "0.3", default-features = false, features = ["sink", "std"] }

# Database and serialization
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# HTTP utilities and state management
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace", "fs"] }
dashmap = "5.5"  # Concurrent HashMap for WebSocket connections
```

## Step 2: Design Real-Time Data Models

**Shuttle Concept**: Real-time applications benefit from models that support both persistent storage and in-memory state management for WebSocket connections.

Create `src/models.rs` with chat domain models:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;
use std::collections::HashMap;

// Persistent chat message
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct ChatMessage {
    pub id: Uuid,
    pub room_id: String,
    pub user_id: Uuid,
    pub username: String,
    pub content: String,
    pub message_type: MessageType,
    pub created_at: DateTime<Utc>,
}

// Chat room for organizing conversations
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct ChatRoom {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub is_active: bool,
}

// Connected user session (in-memory)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedUser {
    pub user_id: Uuid,
    pub username: String,
    pub room_id: String,
    pub connected_at: DateTime<Utc>,
    pub last_activity: DateTime<Utc>,
}

// Message types for different WebSocket events
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "message_type", rename_all = "lowercase")]
pub enum MessageType {
    Text,
    UserJoined,
    UserLeft,
    Typing,
    System,
}

// WebSocket message payloads
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum WebSocketMessage {
    // Incoming messages from client
    JoinRoom { room_id: String, username: String },
    SendMessage { room_id: String, content: String },
    LeaveRoom { room_id: String },
    StartTyping { room_id: String },
    StopTyping { room_id: String },

    // Outgoing messages to client
    MessageReceived { message: ChatMessage },
    UserJoined { user: ConnectedUser, room_id: String },
    UserLeft { user_id: Uuid, username: String, room_id: String },
    UserTyping { user_id: Uuid, username: String, room_id: String, is_typing: bool },
    RoomUsers { room_id: String, users: Vec<ConnectedUser> },
    Error { message: String },
    ConnectionEstablished { user_id: Uuid, room_id: String },
}

// Room statistics for monitoring
#[derive(Debug, Serialize)]
pub struct RoomStats {
    pub room_id: String,
    pub name: String,
    pub connected_users: usize,
    pub total_messages: i64,
    pub last_message_at: Option<DateTime<Utc>>,
}

// Request payloads for HTTP API
#[derive(Debug, Deserialize)]
pub struct CreateRoomRequest {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct MessageHistoryQuery {
    pub room_id: String,
    pub limit: Option<usize>,
    pub before: Option<DateTime<Utc>>,
}

// Response wrappers
#[derive(Debug, Serialize)]
pub struct ChatRoomsResponse {
    pub rooms: Vec<ChatRoom>,
    pub total: usize,
}

#[derive(Debug, Serialize)]
pub struct MessageHistoryResponse {
    pub messages: Vec<ChatMessage>,
    pub room_id: String,
    pub has_more: bool,
}

#[derive(Debug, Serialize)]
pub struct RoomStatsResponse {
    pub rooms: Vec<RoomStats>,
    pub total_connected_users: usize,
    pub total_rooms: usize,
}

// Error response
#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Default for MessageType {
    fn default() -> Self {
        MessageType::Text
    }
}

impl ErrorResponse {
    pub fn new(error: &str, message: &str) -> Self {
        Self {
            error: error.to_string(),
            message: message.to_string(),
            timestamp: Utc::now(),
        }
    }
}

// In-memory connection state
pub type ConnectionMap = std::sync::Arc<dashmap::DashMap<Uuid, tokio::sync::mpsc::UnboundedSender<WebSocketMessage>>>;
pub type RoomUserMap = std::sync::Arc<dashmap::DashMap<String, std::collections::HashSet<Uuid>>>;
pub type UserRoomMap = std::sync::Arc<dashmap::DashMap<Uuid, ConnectedUser>>;
```

## Step 3: Implement WebSocket Connection Management

**Shuttle Concept**: Shuttle applications handle WebSocket connections with automatic scaling and efficient state management patterns.

Create `src/websocket.rs` for WebSocket handling:

```rust
use crate::models::*;
use axum::{
    extract::{
        ws::{Message, WebSocket, WebSocketUpgrade},
        State,
    },
    response::Response,
};
use futures_util::{sink::SinkExt, stream::StreamExt};
use sqlx::PgPool;
use std::sync::Arc;
use tokio::sync::mpsc;
use tracing::{error, info, warn};
use uuid::Uuid;

// WebSocket connection manager
pub struct WebSocketManager {
    pub pool: PgPool,
    pub connections: ConnectionMap,
    pub room_users: RoomUserMap,
    pub user_rooms: UserRoomMap,
}

impl WebSocketManager {
    pub fn new(pool: PgPool) -> Self {
        Self {
            pool,
            connections: Arc::new(dashmap::DashMap::new()),
            room_users: Arc::new(dashmap::DashMap::new()),
            user_rooms: Arc::new(dashmap::DashMap::new()),
        }
    }

    // Handle new WebSocket connection
    pub async fn handle_connection(
        &self,
        ws: WebSocketUpgrade,
    ) -> Response {
        ws.on_upgrade(move |socket| self.handle_socket(socket))
    }

    // Handle individual WebSocket session
    async fn handle_socket(&self, socket: WebSocket) {
        let (mut sender, mut receiver) = socket.split();
        let (tx, mut rx) = mpsc::unbounded_channel::<WebSocketMessage>();

        let user_id = Uuid::new_v4();

        // Store connection for broadcasting
        self.connections.insert(user_id, tx.clone());

        info!("New WebSocket connection established: {}", user_id);

        // Send messages to WebSocket client
        let send_task = tokio::spawn(async move {
            while let Some(message) = rx.recv().await {
                let message_text = match serde_json::to_string(&message) {
                    Ok(text) => text,
                    Err(e) => {
                        error!("Failed to serialize message: {}", e);
                        continue;
                    }
                };

                if sender.send(Message::Text(message_text)).await.is_err() {
                    break; // Connection closed
                }
            }
        });

        // Receive messages from WebSocket client
        let connections = self.connections.clone();
        let room_users = self.room_users.clone();
        let user_rooms = self.user_rooms.clone();
        let pool = self.pool.clone();

        let receive_task = tokio::spawn(async move {
            while let Some(message) = receiver.next().await {
                match message {
                    Ok(Message::Text(text)) => {
                        if let Err(e) = Self::handle_message(
                            user_id,
                            &text,
                            &pool,
                            &connections,
                            &room_users,
                            &user_rooms,
                        ).await {
                            error!("Failed to handle message: {}", e);
                            // Send error back to client
                            if let Some(sender) = connections.get(&user_id) {
                                let _ = sender.send(WebSocketMessage::Error {
                                    message: format!("Message handling error: {}", e),
                                });
                            }
                        }
                    }
                    Ok(Message::Close(_)) => {
                        info!("WebSocket connection closed: {}", user_id);
                        break;
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                    _ => {} // Ignore other message types
                }
            }
        });

        // Wait for either task to complete
        tokio::select! {
            _ = send_task => {},
            _ = receive_task => {},
        }

        // Cleanup connection
        self.cleanup_connection(user_id).await;
    }

    // Handle incoming WebSocket messages
    async fn handle_message(
        user_id: Uuid,
        message_text: &str,
        pool: &PgPool,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        user_rooms: &UserRoomMap,
    ) -> Result<(), String> {
        let message: WebSocketMessage = serde_json::from_str(message_text)
            .map_err(|e| format!("Invalid message format: {}", e))?;

        match message {
            WebSocketMessage::JoinRoom { room_id, username } => {
                Self::handle_join_room(
                    user_id,
                    &room_id,
                    &username,
                    pool,
                    connections,
                    room_users,
                    user_rooms,
                ).await?;
            }

            WebSocketMessage::SendMessage { room_id, content } => {
                Self::handle_send_message(
                    user_id,
                    &room_id,
                    &content,
                    pool,
                    connections,
                    room_users,
                    user_rooms,
                ).await?;
            }

            WebSocketMessage::LeaveRoom { room_id } => {
                Self::handle_leave_room(
                    user_id,
                    &room_id,
                    connections,
                    room_users,
                    user_rooms,
                ).await?;
            }

            WebSocketMessage::StartTyping { room_id } => {
                Self::handle_typing_indicator(
                    user_id,
                    &room_id,
                    true,
                    connections,
                    room_users,
                    user_rooms,
                ).await?;
            }

            WebSocketMessage::StopTyping { room_id } => {
                Self::handle_typing_indicator(
                    user_id,
                    &room_id,
                    false,
                    connections,
                    room_users,
                    user_rooms,
                ).await?;
            }

            _ => {
                return Err("Invalid incoming message type".to_string());
            }
        }

        Ok(())
    }

    // Handle user joining a room
    async fn handle_join_room(
        user_id: Uuid,
        room_id: &str,
        username: &str,
        pool: &PgPool,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        user_rooms: &UserRoomMap,
    ) -> Result<(), String> {
        // Verify room exists
        let room_exists = sqlx::query!("SELECT id FROM chat_rooms WHERE id = $1", room_id)
            .fetch_optional(pool)
            .await
            .map_err(|e| format!("Database error: {}", e))?
            .is_some();

        if !room_exists {
            return Err("Room does not exist".to_string());
        }

        // Create connected user
        let connected_user = ConnectedUser {
            user_id,
            username: username.to_string(),
            room_id: room_id.to_string(),
            connected_at: chrono::Utc::now(),
            last_activity: chrono::Utc::now(),
        };

        // Update in-memory state
        user_rooms.insert(user_id, connected_user.clone());
        room_users.entry(room_id.to_string())
            .or_insert_with(std::collections::HashSet::new)
            .insert(user_id);

        // Notify client of successful connection
        if let Some(sender) = connections.get(&user_id) {
            let _ = sender.send(WebSocketMessage::ConnectionEstablished {
                user_id,
                room_id: room_id.to_string(),
            });
        }

        // Broadcast user joined to room
        Self::broadcast_to_room(
            room_id,
            WebSocketMessage::UserJoined {
                user: connected_user,
                room_id: room_id.to_string(),
            },
            connections,
            room_users,
            Some(user_id), // Exclude the joining user
        ).await;

        // Send current room users to the joining user
        let current_users: Vec<ConnectedUser> = room_users
            .get(room_id)
            .map(|users| {
                users.iter()
                    .filter_map(|&uid| user_rooms.get(&uid).map(|u| u.clone()))
                    .collect()
            })
            .unwrap_or_default();

        if let Some(sender) = connections.get(&user_id) {
            let _ = sender.send(WebSocketMessage::RoomUsers {
                room_id: room_id.to_string(),
                users: current_users,
            });
        }

        info!("User {} joined room {}", username, room_id);
        Ok(())
    }

    // Handle sending a message
    async fn handle_send_message(
        user_id: Uuid,
        room_id: &str,
        content: &str,
        pool: &PgPool,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        user_rooms: &UserRoomMap,
    ) -> Result<(), String> {
        // Get user info
        let user_info = user_rooms.get(&user_id)
            .ok_or("User not in any room")?;

        if user_info.room_id != room_id {
            return Err("User not in specified room".to_string());
        }

        // Save message to database
        let message = sqlx::query_as::<_, ChatMessage>(
            r#"
            INSERT INTO chat_messages (room_id, user_id, username, content, message_type)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id, room_id, user_id, username, content, message_type, created_at
            "#,
        )
        .bind(room_id)
        .bind(user_id)
        .bind(&user_info.username)
        .bind(content)
        .bind(MessageType::Text)
        .fetch_one(pool)
        .await
        .map_err(|e| format!("Failed to save message: {}", e))?;

        // Broadcast message to room
        Self::broadcast_to_room(
            room_id,
            WebSocketMessage::MessageReceived { message },
            connections,
            room_users,
            None, // Send to all users in room
        ).await;

        Ok(())
    }

    // Handle leaving a room
    async fn handle_leave_room(
        user_id: Uuid,
        room_id: &str,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        user_rooms: &UserRoomMap,
    ) -> Result<(), String> {
        let user_info = user_rooms.remove(&user_id)
            .ok_or("User not found")?;

        room_users.entry(room_id.to_string())
            .and_modify(|users| { users.remove(&user_id); });

        // Broadcast user left to room
        Self::broadcast_to_room(
            room_id,
            WebSocketMessage::UserLeft {
                user_id,
                username: user_info.1.username,
                room_id: room_id.to_string(),
            },
            connections,
            room_users,
            Some(user_id),
        ).await;

        Ok(())
    }

    // Handle typing indicators
    async fn handle_typing_indicator(
        user_id: Uuid,
        room_id: &str,
        is_typing: bool,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        user_rooms: &UserRoomMap,
    ) -> Result<(), String> {
        let user_info = user_rooms.get(&user_id)
            .ok_or("User not found")?;

        if user_info.room_id != room_id {
            return Err("User not in specified room".to_string());
        }

        // Broadcast typing indicator to room (excluding sender)
        Self::broadcast_to_room(
            room_id,
            WebSocketMessage::UserTyping {
                user_id,
                username: user_info.username.clone(),
                room_id: room_id.to_string(),
                is_typing,
            },
            connections,
            room_users,
            Some(user_id),
        ).await;

        Ok(())
    }

    // Broadcast message to all users in a room
    async fn broadcast_to_room(
        room_id: &str,
        message: WebSocketMessage,
        connections: &ConnectionMap,
        room_users: &RoomUserMap,
        exclude_user: Option<Uuid>,
    ) {
        if let Some(users) = room_users.get(room_id) {
            for &user_id in users.iter() {
                if Some(user_id) == exclude_user {
                    continue;
                }

                if let Some(sender) = connections.get(&user_id) {
                    if sender.send(message.clone()).is_err() {
                        warn!("Failed to send message to user {}", user_id);
                    }
                }
            }
        }
    }

    // Cleanup when connection is closed
    async fn cleanup_connection(&self, user_id: Uuid) {
        info!("Cleaning up connection for user: {}", user_id);

        // Remove from connections
        self.connections.remove(&user_id);

        // Remove from user rooms and notify
        if let Some((_, user_info)) = self.user_rooms.remove(&user_id) {
            let room_id = &user_info.room_id;

            // Remove from room users
            self.room_users.entry(room_id.clone())
                .and_modify(|users| { users.remove(&user_id); });

            // Broadcast user left
            Self::broadcast_to_room(
                room_id,
                WebSocketMessage::UserLeft {
                    user_id,
                    username: user_info.username,
                    room_id: room_id.clone(),
                },
                &self.connections,
                &self.room_users,
                Some(user_id),
            ).await;
        }
    }

    // Get current room statistics
    pub async fn get_room_stats(&self) -> RoomStatsResponse {
        let total_connected_users = self.user_rooms.len();
        let total_rooms = self.room_users.len();

        let rooms: Vec<RoomStats> = self.room_users
            .iter()
            .map(|entry| {
                let (room_id, users) = entry.pair();
                RoomStats {
                    room_id: room_id.clone(),
                    name: room_id.clone(), // In real app, would fetch from database
                    connected_users: users.len(),
                    total_messages: 0, // Would query database
                    last_message_at: None, // Would query database
                }
            })
            .collect();

        RoomStatsResponse {
            rooms,
            total_connected_users,
            total_rooms,
        }
    }
}
```

## Step 4: Set Up Database Schema for Chat

**Shuttle Concept**: Shuttle applications handle real-time data persistence with schemas optimized for both current state and historical data.

Create `src/database.rs` for chat schema:

```rust
use sqlx::PgPool;
use tracing::{info, error};

// Initialize chat database schema
pub async fn initialize_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    info!("ðŸ”§ Initializing Real-Time Chat database schema...");

    // Create message type enum
    sqlx::query(
        r#"
        DO $$ BEGIN
            CREATE TYPE message_type AS ENUM ('text', 'userjoined', 'userleft', 'typing', 'system');
        EXCEPTION
            WHEN duplicate_object THEN null;
        END $$;
        "#,
    )
    .execute(pool)
    .await?;

    // Create chat rooms table
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS chat_rooms (
            id VARCHAR(50) PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            description TEXT,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            is_active BOOLEAN NOT NULL DEFAULT true,

            CONSTRAINT room_id_format CHECK (id ~ '^[a-z0-9-_]+$'),
            CONSTRAINT name_length CHECK (length(name) >= 1 AND length(name) <= 255)
        );

        CREATE INDEX IF NOT EXISTS idx_chat_rooms_active ON chat_rooms(is_active);
        CREATE INDEX IF NOT EXISTS idx_chat_rooms_created ON chat_rooms(created_at);
        "#,
    )
    .execute(pool)
    .await?;

    // Create chat messages table with performance optimizations
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS chat_messages (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            room_id VARCHAR(50) NOT NULL REFERENCES chat_rooms(id) ON DELETE CASCADE,
            user_id UUID NOT NULL,
            username VARCHAR(100) NOT NULL,
            content TEXT NOT NULL,
            message_type message_type NOT NULL DEFAULT 'text',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

            CONSTRAINT content_length CHECK (length(content) >= 1 AND length(content) <= 2000),
            CONSTRAINT username_length CHECK (length(username) >= 1 AND length(username) <= 100)
        );

        -- Indexes for efficient message queries
        CREATE INDEX IF NOT EXISTS idx_chat_messages_room_time ON chat_messages(room_id, created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_chat_messages_user ON chat_messages(user_id);
        CREATE INDEX IF NOT EXISTS idx_chat_messages_type ON chat_messages(message_type);

        -- Partial index for recent messages (last 30 days)
        CREATE INDEX IF NOT EXISTS idx_chat_messages_recent
        ON chat_messages(room_id, created_at DESC)
        WHERE created_at > NOW() - INTERVAL '30 days';
        "#,
    )
    .execute(pool)
    .await?;

    // Insert default chat rooms
    sqlx::query(
        r#"
        INSERT INTO chat_rooms (id, name, description) VALUES
        ('general', 'General Chat', 'Welcome to the general discussion room'),
        ('tech', 'Tech Talk', 'Discuss technology, programming, and development'),
        ('random', 'Random', 'Off-topic conversations and fun discussions'),
        ('help', 'Help & Support', 'Get help and support from the community')
        ON CONFLICT (id) DO NOTHING;
        "#,
    )
    .execute(pool)
    .await?;

    info!("âœ… Chat database schema initialized successfully");
    Ok(())
}

// Database health check with chat statistics
pub async fn check_database_health(pool: &PgPool) -> Result<DatabaseStats, sqlx::Error> {
    let stats = sqlx::query!(
        r#"
        SELECT
            (SELECT COUNT(*) FROM chat_rooms WHERE is_active = true) as active_rooms,
            (SELECT COUNT(*) FROM chat_messages) as total_messages,
            (SELECT COUNT(*) FROM chat_messages WHERE created_at > NOW() - INTERVAL '1 hour') as messages_last_hour,
            (SELECT COUNT(DISTINCT user_id) FROM chat_messages WHERE created_at > NOW() - INTERVAL '24 hours') as active_users_24h
        "#
    )
    .fetch_one(pool)
    .await?;

    Ok(DatabaseStats {
        active_rooms: stats.active_rooms.unwrap_or(0),
        total_messages: stats.total_messages.unwrap_or(0),
        messages_last_hour: stats.messages_last_hour.unwrap_or(0),
        active_users_24h: stats.active_users_24h.unwrap_or(0),
    })
}

#[derive(Debug, serde::Serialize)]
pub struct DatabaseStats {
    pub active_rooms: i64,
    pub total_messages: i64,
    pub messages_last_hour: i64,
    pub active_users_24h: i64,
}
```

## Step 5: Create Frontend with Static File Serving

**Shuttle Concept**: Shuttle's static file serving allows you to deliver complete frontend applications alongside your WebSocket API.

Create the frontend directory structure:

```bash
mkdir -p static/js static/css
```

Create `static/index.html` with a React-based chat interface:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shuttle Chat App</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="/css/chat.css" />
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // Main Chat Application Component
      function ChatApp() {
        const [ws, setWs] = useState(null);
        const [connected, setConnected] = useState(false);
        const [currentRoom, setCurrentRoom] = useState("");
        const [username, setUsername] = useState("");
        const [messages, setMessages] = useState([]);
        const [connectedUsers, setConnectedUsers] = useState([]);
        const [typingUsers, setTypingUsers] = useState(new Set());
        const [newMessage, setNewMessage] = useState("");
        const [rooms, setRooms] = useState([]);
        const [isJoined, setIsJoined] = useState(false);

        const messagesEndRef = useRef(null);
        const typingTimeoutRef = useRef(null);

        // Initialize WebSocket connection
        useEffect(() => {
          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/ws`;

          const websocket = new WebSocket(wsUrl);

          websocket.onopen = () => {
            console.log("WebSocket connected");
            setConnected(true);
            setWs(websocket);
          };

          websocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            handleWebSocketMessage(message);
          };

          websocket.onclose = () => {
            console.log("WebSocket disconnected");
            setConnected(false);
            setWs(null);
            setIsJoined(false);
          };

          websocket.onerror = (error) => {
            console.error("WebSocket error:", error);
          };

          return () => {
            websocket.close();
          };
        }, []);

        // Load available rooms
        useEffect(() => {
          fetch("/api/rooms")
            .then((res) => res.json())
            .then((data) => setRooms(data.rooms))
            .catch((err) => console.error("Failed to load rooms:", err));
        }, []);

        // Auto-scroll to bottom of messages
        useEffect(() => {
          messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
        }, [messages]);

        // Handle incoming WebSocket messages
        const handleWebSocketMessage = (message) => {
          switch (message.type) {
            case "MessageReceived":
              setMessages((prev) => [...prev, message.data.message]);
              break;

            case "UserJoined":
              setConnectedUsers((prev) => [...prev, message.data.user]);
              setMessages((prev) => [
                ...prev,
                {
                  id: Date.now(),
                  content: `${message.data.user.username} joined the room`,
                  message_type: "system",
                  created_at: new Date().toISOString(),
                },
              ]);
              break;

            case "UserLeft":
              setConnectedUsers((prev) =>
                prev.filter((u) => u.user_id !== message.data.user_id)
              );
              setMessages((prev) => [
                ...prev,
                {
                  id: Date.now(),
                  content: `${message.data.username} left the room`,
                  message_type: "system",
                  created_at: new Date().toISOString(),
                },
              ]);
              break;

            case "RoomUsers":
              setConnectedUsers(message.data.users);
              break;

            case "UserTyping":
              setTypingUsers((prev) => {
                const newSet = new Set(prev);
                if (message.data.is_typing) {
                  newSet.add(message.data.username);
                } else {
                  newSet.delete(message.data.username);
                }
                return newSet;
              });
              break;

            case "ConnectionEstablished":
              setIsJoined(true);
              loadMessageHistory(message.data.room_id);
              break;

            case "Error":
              alert(`Error: ${message.data.message}`);
              break;

            default:
              console.log("Unknown message type:", message.type);
          }
        };

        // Load message history for room
        const loadMessageHistory = async (roomId) => {
          try {
            const response = await fetch(
              `/api/messages?room_id=${roomId}&limit=50`
            );
            const data = await response.json();
            setMessages(data.messages.reverse()); // Reverse to show oldest first
          } catch (error) {
            console.error("Failed to load message history:", error);
          }
        };

        // Join a chat room
        const joinRoom = () => {
          if (!ws || !username.trim() || !currentRoom) return;

          setMessages([]);
          setConnectedUsers([]);
          setTypingUsers(new Set());

          ws.send(
            JSON.stringify({
              type: "JoinRoom",
              data: { room_id: currentRoom, username: username.trim() },
            })
          );
        };

        // Send a message
        const sendMessage = () => {
          if (!ws || !newMessage.trim() || !isJoined) return;

          ws.send(
            JSON.stringify({
              type: "SendMessage",
              data: { room_id: currentRoom, content: newMessage.trim() },
            })
          );

          setNewMessage("");
          stopTyping();
        };

        // Handle typing indicators
        const startTyping = () => {
          if (!ws || !isJoined) return;

          ws.send(
            JSON.stringify({
              type: "StartTyping",
              data: { room_id: currentRoom },
            })
          );

          // Auto-stop typing after 3 seconds
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
          }
          typingTimeoutRef.current = setTimeout(stopTyping, 3000);
        };

        const stopTyping = () => {
          if (!ws || !isJoined) return;

          ws.send(
            JSON.stringify({
              type: "StopTyping",
              data: { room_id: currentRoom },
            })
          );

          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
            typingTimeoutRef.current = null;
          }
        };

        // Format timestamp
        const formatTime = (timestamp) => {
          return new Date(timestamp).toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          });
        };

        // Connection form
        if (!isJoined) {
          return (
            <div className="connection-form">
              <div className="form-container">
                <h1>ðŸš€ Shuttle Chat</h1>
                <p>Real-time chat powered by Shuttle WebSockets</p>

                <div className="form-group">
                  <label>Username:</label>
                  <input
                    type="text"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    placeholder="Enter your username"
                    onKeyPress={(e) => e.key === "Enter" && joinRoom()}
                  />
                </div>

                <div className="form-group">
                  <label>Room:</label>
                  <select
                    value={currentRoom}
                    onChange={(e) => setCurrentRoom(e.target.value)}
                  >
                    <option value="">Select a room</option>
                    {rooms.map((room) => (
                      <option key={room.id} value={room.id}>
                        #{room.name}
                      </option>
                    ))}
                  </select>
                </div>

                <button
                  onClick={joinRoom}
                  disabled={!connected || !username.trim() || !currentRoom}
                  className="join-button"
                >
                  {connected ? "Join Room" : "Connecting..."}
                </button>
              </div>
            </div>
          );
        }

        // Main chat interface
        return (
          <div className="chat-app">
            <header className="chat-header">
              <h1>
                #{rooms.find((r) => r.id === currentRoom)?.name || currentRoom}
              </h1>
              <div className="user-info">
                <span>
                  Connected as: <strong>{username}</strong>
                </span>
                <span className="connection-status">
                  {connected ? "ðŸŸ¢ Connected" : "ðŸ”´ Disconnected"}
                </span>
              </div>
            </header>

            <div className="chat-container">
              <div className="chat-main">
                <div className="messages-container">
                  {messages.map((message, index) => (
                    <div
                      key={message.id || index}
                      className={`message ${message.message_type || "text"}`}
                    >
                      {message.message_type === "system" ? (
                        <div className="system-message">
                          <em>{message.content}</em>
                        </div>
                      ) : (
                        <>
                          <div className="message-header">
                            <span className="username">{message.username}</span>
                            <span className="timestamp">
                              {formatTime(message.created_at)}
                            </span>
                          </div>
                          <div className="message-content">
                            {message.content}
                          </div>
                        </>
                      )}
                    </div>
                  ))}

                  {typingUsers.size > 0 && (
                    <div className="typing-indicator">
                      <em>
                        {Array.from(typingUsers).join(", ")}
                        {typingUsers.size === 1 ? " is" : " are"} typing...
                      </em>
                    </div>
                  )}

                  <div ref={messagesEndRef} />
                </div>

                <div className="message-input">
                  <input
                    type="text"
                    value={newMessage}
                    onChange={(e) => {
                      setNewMessage(e.target.value);
                      if (e.target.value && !typingTimeoutRef.current) {
                        startTyping();
                      } else if (!e.target.value) {
                        stopTyping();
                      }
                    }}
                    onKeyPress={(e) => e.key === "Enter" && sendMessage()}
                    placeholder="Type a message..."
                    disabled={!connected}
                  />
                  <button
                    onClick={sendMessage}
                    disabled={!connected || !newMessage.trim()}
                  >
                    Send
                  </button>
                </div>
              </div>

              <div className="sidebar">
                <h3>Connected Users ({connectedUsers.length})</h3>
                <div className="user-list">
                  {connectedUsers.map((user) => (
                    <div key={user.user_id} className="user-item">
                      <span className="user-status">ðŸŸ¢</span>
                      <span className="user-name">{user.username}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Render the app
      ReactDOM.render(<ChatApp />, document.getElementById("root"));
    </script>
  </body>
</html>
```

Create `static/css/chat.css` for styling:

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  height: 100vh;
  overflow: hidden;
}

.connection-form {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  padding: 20px;
}

.form-container {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  max-width: 400px;
  width: 100%;
  text-align: center;
}

.form-container h1 {
  color: #333;
  margin-bottom: 0.5rem;
  font-size: 2rem;
}

.form-container p {
  color: #666;
  margin-bottom: 2rem;
}

.form-group {
  margin-bottom: 1.5rem;
  text-align: left;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: #333;
}

.form-group input,
.form-group select {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid #e1e5e9;
  border-radius: 6px;
  font-size: 1rem;
  transition: border-color 0.3s;
}

.form-group input:focus,
.form-group select:focus {
  outline: none;
  border-color: #667eea;
}

.join-button {
  width: 100%;
  padding: 0.75rem;
  background: #667eea;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s;
}

.join-button:hover:not(:disabled) {
  background: #5a6fd8;
}

.join-button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.chat-app {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: white;
}

.chat-header {
  background: #667eea;
  color: white;
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.chat-header h1 {
  font-size: 1.5rem;
  font-weight: 600;
}

.user-info {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.25rem;
}

.connection-status {
  font-size: 0.875rem;
  opacity: 0.9;
}

.chat-container {
  flex: 1;
  display: flex;
  height: calc(100vh - 80px);
}

.chat-main {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.messages-container {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  background: #f8f9fa;
}

.message {
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.message.system {
  background: #e3f2fd;
  text-align: center;
  font-style: italic;
  color: #1976d2;
}

.message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.username {
  font-weight: 600;
  color: #667eea;
}

.timestamp {
  font-size: 0.75rem;
  color: #666;
}

.message-content {
  line-height: 1.5;
  word-wrap: break-word;
}

.typing-indicator {
  padding: 0.5rem;
  color: #666;
  font-style: italic;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.message-input {
  display: flex;
  padding: 1rem;
  background: white;
  border-top: 1px solid #e1e5e9;
  gap: 0.5rem;
}

.message-input input {
  flex: 1;
  padding: 0.75rem;
  border: 2px solid #e1e5e9;
  border-radius: 20px;
  font-size: 1rem;
  outline: none;
  transition: border-color 0.3s;
}

.message-input input:focus {
  border-color: #667eea;
}

.message-input button {
  padding: 0.75rem 1.5rem;
  background: #667eea;
  color: white;
  border: none;
  border-radius: 20px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s;
}

.message-input button:hover:not(:disabled) {
  background: #5a6fd8;
}

.message-input button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.sidebar {
  width: 250px;
  background: #f8f9fa;
  border-left: 1px solid #e1e5e9;
  padding: 1rem;
}

.sidebar h3 {
  color: #333;
  margin-bottom: 1rem;
  font-size: 1rem;
}

.user-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.user-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  background: white;
  border-radius: 6px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.user-status {
  font-size: 0.75rem;
}

.user-name {
  font-weight: 500;
  color: #333;
}

@media (max-width: 768px) {
  .chat-container {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    max-height: 150px;
    border-left: none;
    border-top: 1px solid #e1e5e9;
  }

  .chat-header {
    padding: 1rem;
  }

  .user-info {
    align-items: flex-start;
  }
}
```

## Step 6: Build Complete WebSocket Application

**Shuttle Concept**: Shuttle applications integrate WebSocket handling, static file serving, and database resources into unified full-stack applications.

Update `src/main.rs` with the complete chat application:

```rust
mod models;
mod websocket;
mod database;

use axum::{
    extract::{Query, State, Path},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use database::*;
use models::*;
use shuttle_static_folder::StaticFolder;
use sqlx::PgPool;
use std::sync::Arc;
use tower_http::{cors::CorsLayer, services::ServeDir};
use websocket::WebSocketManager;

// Application state with WebSocket manager
#[derive(Clone)]
pub struct AppState {
    pub ws_manager: Arc<WebSocketManager>,
}

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] pool: PgPool,
    #[shuttle_static_folder::StaticFolder(folder = "static")] static_folder: StaticFolder,
) -> shuttle_axum::ShuttleAxum {
    // Initialize database schema
    initialize_database(&pool)
        .await
        .expect("Failed to initialize database schema");

    // Create WebSocket manager with database pool
    let ws_manager = Arc::new(WebSocketManager::new(pool));
    let state = AppState { ws_manager };

    // Build comprehensive real-time application
    let app = Router::new()
        .route("/health", get(health_check))

        // WebSocket endpoint
        .route("/ws", get(websocket_handler))

        // HTTP API for chat functionality
        .route("/api/rooms", get(list_rooms).post(create_room))
        .route("/api/rooms/:id", get(get_room))
        .route("/api/messages", get(get_message_history))
        .route("/api/stats", get(get_real_time_stats))

        // Serve static files (React frontend)
        .fallback_service(ServeDir::new(static_folder.path))

        .layer(CorsLayer::permissive())
        .with_state(state);

    Ok(app.into())
}

// Health check with real-time statistics
async fn health_check(State(state): State<AppState>) -> Json<serde_json::Value> {
    let db_stats = check_database_health(&state.ws_manager.pool)
        .await
        .unwrap_or(DatabaseStats {
            active_rooms: 0,
            total_messages: 0,
            messages_last_hour: 0,
            active_users_24h: 0,
        });

    let ws_stats = state.ws_manager.get_room_stats().await;

    Json(serde_json::json!({
        "status": "healthy",
        "database": "connected",
        "websocket": "enabled",
        "database_stats": db_stats,
        "websocket_stats": {
            "connected_users": ws_stats.total_connected_users,
            "active_rooms": ws_stats.total_rooms
        },
        "timestamp": chrono::Utc::now(),
        "service": "chat-app"
    }))
}

// WebSocket connection handler
async fn websocket_handler(
    ws: axum::extract::ws::WebSocketUpgrade,
    State(state): State<AppState>,
) -> axum::response::Response {
    state.ws_manager.handle_connection(ws).await
}

// HTTP API handlers for chat functionality
async fn list_rooms(
    State(state): State<AppState>,
) -> Result<Json<ChatRoomsResponse>, (StatusCode, Json<ErrorResponse>)> {
    let rooms = sqlx::query_as::<_, ChatRoom>(
        "SELECT id, name, description, created_at, is_active FROM chat_rooms WHERE is_active = true ORDER BY name"
    )
    .fetch_all(&state.ws_manager.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse::new("database_error", "Failed to fetch rooms")),
        )
    })?;

    Ok(Json(ChatRoomsResponse {
        total: rooms.len(),
        rooms,
    }))
}

async fn create_room(
    State(state): State<AppState>,
    Json(request): Json<CreateRoomRequest>,
) -> Result<(StatusCode, Json<ChatRoom>), (StatusCode, Json<ErrorResponse>)> {
    // Validate room ID format (alphanumeric, hyphens, underscores only)
    if !request.id.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse::new("validation_error", "Room ID can only contain letters, numbers, hyphens, and underscores")),
        ));
    }

    if request.name.trim().is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse::new("validation_error", "Room name cannot be empty")),
        ));
    }

    let room = sqlx::query_as::<_, ChatRoom>(
        r#"
        INSERT INTO chat_rooms (id, name, description)
        VALUES ($1, $2, $3)
        RETURNING id, name, description, created_at, is_active
        "#,
    )
    .bind(request.id.to_lowercase())
    .bind(request.name.trim())
    .bind(request.description)
    .fetch_one(&state.ws_manager.pool)
    .await
    .map_err(|e| {
        if e.to_string().contains("duplicate key") {
            (
                StatusCode::CONFLICT,
                Json(ErrorResponse::new("duplicate_error", "Room ID already exists")),
            )
        } else {
            tracing::error!("Database error: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ErrorResponse::new("database_error", "Failed to create room")),
            )
        }
    })?;

    Ok((StatusCode::CREATED, Json(room)))
}

async fn get_room(
    State(state): State<AppState>,
    Path(room_id): Path<String>,
) -> Result<Json<ChatRoom>, (StatusCode, Json<ErrorResponse>)> {
    let room = sqlx::query_as::<_, ChatRoom>(
        "SELECT id, name, description, created_at, is_active FROM chat_rooms WHERE id = $1"
    )
    .bind(room_id)
    .fetch_optional(&state.ws_manager.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse::new("database_error", "Failed to fetch room")),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ErrorResponse::new("not_found", "Room not found")),
        )
    })?;

    Ok(Json(room))
}

async fn get_message_history(
    State(state): State<AppState>,
    Query(params): Query<MessageHistoryQuery>,
) -> Result<Json<MessageHistoryResponse>, (StatusCode, Json<ErrorResponse>)> {
    let limit = params.limit.unwrap_or(50).min(100);

    let messages = if let Some(before) = params.before {
        sqlx::query_as::<_, ChatMessage>(
            r#"
            SELECT id, room_id, user_id, username, content, message_type, created_at
            FROM chat_messages
            WHERE room_id = $1 AND created_at < $2 AND message_type = 'text'
            ORDER BY created_at DESC
            LIMIT $3
            "#,
        )
        .bind(&params.room_id)
        .bind(before)
        .bind(limit as i64)
    } else {
        sqlx::query_as::<_, ChatMessage>(
            r#"
            SELECT id, room_id, user_id, username, content, message_type, created_at
            FROM chat_messages
            WHERE room_id = $1 AND message_type = 'text'
            ORDER BY created_at DESC
            LIMIT $2
            "#,
        )
        .bind(&params.room_id)
        .bind(limit as i64)
    }
    .fetch_all(&state.ws_manager.pool)
    .await
    .map_err(|e| {
        tracing::error!("Database error: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse::new("database_error", "Failed to fetch message history")),
        )
    })?;

    let has_more = messages.len() == limit;

    Ok(Json(MessageHistoryResponse {
        messages,
        room_id: params.room_id,
        has_more,
    }))
}

async fn get_real_time_stats(
    State(state): State<AppState>,
) -> Json<RoomStatsResponse> {
    Json(state.ws_manager.get_room_stats().await)
}
```

## Step 7: Test Real-Time Chat Application

**Shuttle Concept**: Shuttle's local development environment provides the same WebSocket behavior as production, including static file serving and database persistence.

Start your real-time chat application:

```bash
cargo shuttle run
```

**Test the complete application**:

1. **Open the chat interface**:

   - Visit `http://localhost:8000` in your browser
   - You should see the Shuttle Chat login form

2. **Test multi-user chat**:

   - Open the app in multiple browser windows/tabs
   - Use different usernames
   - Join the same room
   - Send messages and see real-time updates

3. **Test WebSocket API directly**:

```bash
# List available rooms
curl http://localhost:8000/api/rooms

# Create a new room
curl -X POST http://localhost:8000/api/rooms \
  -H "Content-Type: application/json" \
  -d '{"id": "dev-chat", "name": "Developer Chat", "description": "For developers only"}'

# Get message history
curl "http://localhost:8000/api/messages?room_id=general&limit=10"

# Check real-time statistics
curl http://localhost:8000/api/stats
```

**What you'll observe**:

- **Real-time messaging** - Messages appear instantly across all connected clients
- **User presence** - See who's online in each room
- **Typing indicators** - Real-time typing notifications
- **Message persistence** - Chat history loads from database
- **Connection management** - Automatic cleanup when users disconnect

## Step 8: Deploy Real-Time Application to Production

**Shuttle Concept**: Shuttle deployment handles WebSocket scaling, static file distribution, and database replication automatically for production real-time applications.

Deploy your chat application:

```bash
cargo shuttle deploy
```

**What Shuttle provides for production WebSockets**:

- **Automatic WebSocket scaling** - Handles thousands of concurrent connections
- **Static file CDN** - Fast frontend delivery worldwide
- **Database persistence** - Managed PostgreSQL with message history
- **Connection recovery** - Robust WebSocket connection handling

Test your production chat app:

```bash
# Replace with your deployment URL
export CHAT_URL="https://chat-app-yourusername.shuttle.app"

# Check production health
curl $CHAT_URL/health

# Test production API
curl $CHAT_URL/api/rooms

# Open the production chat
open $CHAT_URL  # or visit in browser
```

## What You've Learned (Key Shuttle Concepts)

You've mastered these essential **Shuttle real-time patterns**:

- **WebSocket Integration with Shuttle** - Real-time bidirectional communication using Axum WebSockets with automatic connection lifecycle management and message broadcasting
- **Static File Serving Resource** - Frontend delivery through Shuttle's built-in static folder for complete full-stack applications with single deployment
- **Stateful Real-Time Architecture** - In-memory connection management with DashMap, database message persistence, and user presence tracking patterns
- **Production WebSocket Scaling** - Concurrent connection handling with Tokio and efficient broadcasting for thousands of simultaneous users
- **Full-Stack Integration** - Seamless coordination between frontend clients, WebSocket server, and PostgreSQL database through Shuttle's resource system
- **Real-Time State Management** - Managing connected users, chat rooms, and typing indicators with automatic cleanup and memory optimization

## Troubleshooting

**WebSocket connection failures?**

- Check browser developer tools for WebSocket errors
- Verify the WebSocket URL protocol (ws:// vs wss://)
- Ensure CORS is properly configured

**Messages not broadcasting?**

- Verify user is properly joined to room
- Check connection cleanup in WebSocket manager
- Review in-memory state consistency

**Frontend not loading?**

- Confirm static folder is properly mounted
- Check that HTML/CSS/JS files are in static/ directory
- Verify fallback service configuration

**Database connection issues?**

- Ensure chat schema is initialized properly
- Check foreign key constraints for messages
- Verify room exists before joining

**Production WebSocket issues?**

- Check WebSocket protocol upgrade in production
- Verify HTTPS certificates for WSS connections
- Monitor connection limits and scaling

## Next Steps

Now that you understand Shuttle's real-time capabilities, explore:

1. **[Serverless Patterns](/tutorials/intermediate/serverless-calendar-app)** - Stateless applications with Shuttle
2. **[Production Deployment](/tutorials/intermediate/url-shortener)** - Advanced deployment patterns
3. **[Multi-Service Apps](/tutorials/advanced/custom-service)** - Complex service orchestration
4. **[Production Monitoring](/tutorials/advanced/send-your-logs-to-datadog)** - Real-time application observability

## Complete Code

The full working code for this tutorial is available in our [GitHub repository](https://github.com/shuttle-hq/shuttle-examples/tree/main/chat-app).
