---
title: "Building REST APIs with Shuttle and Axum"
description: "Learn to build production-ready REST APIs using Shuttle's HTTP routing and state management"
icon: "code"
---

## Learning Objectives

By completing this tutorial, you'll master **Shuttle API patterns** and learn to:

- **Shuttle HTTP Routing**: Build RESTful APIs with Axum and automatic request handling
- **Database State Management**: Share database connections across API endpoints efficiently
- **Request/Response Patterns**: Handle JSON, path parameters, and HTTP status codes
- **Error Handling**: Implement structured error responses with proper HTTP semantics
- **API Testing**: Test endpoints locally before deploying to production

## Prerequisites

- **Time Required**: 20 minutes
- **Rust**: Version 1.75.0 or later ([install here](https://rustup.rs/))
- **Tools**: [Shuttle CLI installed](/getting-started/installation)
- **Accounts**: None required (Shuttle account created automatically)
- **Experience**: Completed [Your First Shuttle App](/tutorials/your-first-app) tutorial

## What We're Building

We'll create **TaskFlow API** - a production task management REST API with full CRUD operations and validation.

This demonstrates building scalable APIs with Shuttle's zero-config database integration and automatic HTTP handling.

**High-level components:**

- **REST API** (Axum framework with JSON responses)
- **PostgreSQL Database** (auto-provisioned with optimized schema)
- **Data Validation** (request validation and error handling)
- **Database Transactions** (ACID operations for data consistency)
- **API Documentation** (built-in endpoint discovery)

## Tutorial Steps

### Step 1: Initialize Your API Project

Create a new REST API project:

```bash
shuttle init --template axum taskflow-api
cd taskflow-api
```

Update `Cargo.toml` with API dependencies:

```toml
[package]
name = "taskflow-api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { version = "0.7", features = ["macros"] }
shuttle-axum = "0.56.0"
shuttle-runtime = "0.56.0"
shuttle-shared-db = "0.56.0"
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "macros", "chrono"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
```

### Step 2: Define API Data Models

Create `src/models.rs` with comprehensive task management types:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct Task {
    pub id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub completed: bool,
    pub priority: TaskPriority,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "task_priority", rename_all = "lowercase")]
pub enum TaskPriority {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Deserialize)]
pub struct CreateTask {
    pub title: String,
    pub description: Option<String>,
    pub priority: Option<TaskPriority>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateTask {
    pub title: Option<String>,
    pub description: Option<String>,
    pub completed: Option<bool>,
    pub priority: Option<TaskPriority>,
}

#[derive(Debug, Serialize)]
pub struct TaskResponse {
    pub task: Task,
}

#[derive(Debug, Serialize)]
pub struct TasksResponse {
    pub tasks: Vec<Task>,
    pub total: usize,
}

#[derive(Debug, Serialize)]
pub struct ApiError {
    pub error: String,
    pub message: String,
    pub details: Option<serde_json::Value>,
}

impl ApiError {
    pub fn new(error: &str, message: &str) -> Self {
        Self {
            error: error.to_string(),
            message: message.to_string(),
            details: None,
        }
    }

    pub fn validation_error(field: &str, issue: &str) -> Self {
        Self {
            error: "validation_error".to_string(),
            message: format!("Validation failed for field '{}'", field),
            details: Some(serde_json::json!({
                "field": field,
                "issue": issue
            })),
        }
    }
}

impl Default for TaskPriority {
    fn default() -> Self {
        TaskPriority::Medium
    }
}
```

### Step 3: Set Up Database Schema

Create `src/database.rs` for database initialization:

```rust
use sqlx::PgPool;

pub async fn initialize_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    // Create custom enum type for task priorities
    sqlx::query!(
        r#"
        DO $$ BEGIN
            CREATE TYPE task_priority AS ENUM ('low', 'medium', 'high', 'critical');
        EXCEPTION
            WHEN duplicate_object THEN null;
        END $$;
        "#
    )
    .execute(pool)
    .await?;

    // Create tasks table with optimized indexes
    sqlx::query!(
        r#"
        CREATE TABLE IF NOT EXISTS tasks (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            title TEXT NOT NULL CHECK (length(trim(title)) > 0),
            description TEXT,
            completed BOOLEAN NOT NULL DEFAULT false,
            priority task_priority NOT NULL DEFAULT 'medium',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Indexes for common query patterns
        CREATE INDEX IF NOT EXISTS idx_tasks_completed ON tasks(completed);
        CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
        CREATE INDEX IF NOT EXISTS idx_tasks_created_at ON tasks(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_tasks_updated_at ON tasks(updated_at DESC);

        -- Composite index for filtering completed tasks by priority
        CREATE INDEX IF NOT EXISTS idx_tasks_completed_priority ON tasks(completed, priority);

        -- Update trigger for updated_at
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $$ language 'plpgsql';

        DROP TRIGGER IF EXISTS update_tasks_updated_at ON tasks;
        CREATE TRIGGER update_tasks_updated_at
            BEFORE UPDATE ON tasks
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
        "#
    )
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn get_database_stats(pool: &PgPool) -> Result<serde_json::Value, sqlx::Error> {
    let stats = sqlx::query!(
        r#"
        SELECT
            COUNT(*) as total_tasks,
            COUNT(*) FILTER (WHERE completed = true) as completed_tasks,
            COUNT(*) FILTER (WHERE priority = 'critical') as critical_tasks,
            COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '24 hours') as tasks_today
        FROM tasks
        "#
    )
    .fetch_one(pool)
    .await?;

    Ok(serde_json::json!({
        "total_tasks": stats.total_tasks,
        "completed_tasks": stats.completed_tasks,
        "critical_tasks": stats.critical_tasks,
        "tasks_today": stats.tasks_today
    }))
}
```

### Step 4: Build REST API Handlers

Create `src/handlers.rs` with full CRUD operations:

```rust
use crate::{database::get_database_stats, models::*};
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
};
use serde::Deserialize;
use sqlx::PgPool;
use std::collections::HashMap;
use uuid::Uuid;

#[derive(Debug, Deserialize)]
pub struct ListTasksQuery {
    pub completed: Option<bool>,
    pub priority: Option<TaskPriority>,
    pub limit: Option<i64>,
    pub offset: Option<i64>,
}

// CREATE: Add a new task
pub async fn create_task(
    State(pool): State<PgPool>,
    Json(create_task): Json<CreateTask>,
) -> Result<(StatusCode, Json<TaskResponse>), (StatusCode, Json<ApiError>)> {
    // Validate title
    if create_task.title.trim().is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ApiError::validation_error("title", "cannot be empty")),
        ));
    }

    // Insert task with proper error handling
    let task = sqlx::query_as!(
        Task,
        r#"
        INSERT INTO tasks (title, description, priority)
        VALUES ($1, $2, $3)
        RETURNING id, title, description, completed, priority AS "priority: TaskPriority", created_at, updated_at
        "#,
        create_task.title.trim(),
        create_task.description,
        create_task.priority.unwrap_or_default() as TaskPriority
    )
    .fetch_one(&pool)
    .await
    .map_err(|e| {
        eprintln!("Database error creating task: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ApiError::new("database_error", "Failed to create task")),
        )
    })?;

    Ok((StatusCode::CREATED, Json(TaskResponse { task })))
}

// READ: Get all tasks with filtering
pub async fn list_tasks(
    State(pool): State<PgPool>,
    Query(query): Query<ListTasksQuery>,
) -> Result<Json<TasksResponse>, (StatusCode, Json<ApiError>)> {
    let limit = query.limit.unwrap_or(50).min(100); // Cap at 100
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"
        SELECT id, title, description, completed, priority AS "priority: TaskPriority", created_at, updated_at
        FROM tasks
        WHERE 1=1
        "#
    );
    let mut conditions = Vec::new();

    // Add filtering conditions
    if let Some(completed) = query.completed {
        conditions.push(format!("AND completed = {}", completed));
    }

    if let Some(priority) = query.priority {
        conditions.push(format!("AND priority = '{:?}'", priority).to_lowercase());
    }

    // Append conditions and ordering
    for condition in conditions {
        sql.push_str(&condition);
    }
    sql.push_str(" ORDER BY created_at DESC LIMIT $1 OFFSET $2");

    let tasks = sqlx::query_as::<_, Task>(&sql)
        .bind(limit)
        .bind(offset)
        .fetch_all(&pool)
        .await
        .map_err(|e| {
            eprintln!("Database error listing tasks: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ApiError::new("database_error", "Failed to fetch tasks")),
            )
        })?;

    Ok(Json(TasksResponse {
        total: tasks.len(),
        tasks,
    }))
}

// READ: Get a specific task by ID
pub async fn get_task(
    State(pool): State<PgPool>,
    Path(task_id): Path<Uuid>,
) -> Result<Json<TaskResponse>, (StatusCode, Json<ApiError>)> {
    let task = sqlx::query_as!(
        Task,
        r#"
        SELECT id, title, description, completed, priority AS "priority: TaskPriority", created_at, updated_at
        FROM tasks
        WHERE id = $1
        "#,
        task_id
    )
    .fetch_optional(&pool)
    .await
    .map_err(|e| {
        eprintln!("Database error fetching task: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ApiError::new("database_error", "Failed to fetch task")),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ApiError::new("not_found", "Task not found")),
        )
    })?;

    Ok(Json(TaskResponse { task }))
}

// UPDATE: Modify an existing task
pub async fn update_task(
    State(pool): State<PgPool>,
    Path(task_id): Path<Uuid>,
    Json(update_task): Json<UpdateTask>,
) -> Result<Json<TaskResponse>, (StatusCode, Json<ApiError>)> {
    // Validate title if provided
    if let Some(ref title) = update_task.title {
        if title.trim().is_empty() {
            return Err((
                StatusCode::BAD_REQUEST,
                Json(ApiError::validation_error("title", "cannot be empty")),
            ));
        }
    }

    // Build dynamic update query
    let mut updates = Vec::new();
    let mut params: Vec<&dyn sqlx::postgres::PgHasArrayType> = vec![&task_id];
    let mut param_index = 2;

    if let Some(ref title) = update_task.title {
        updates.push(format!("title = ${}", param_index));
        params.push(title);
        param_index += 1;
    }

    if let Some(ref description) = update_task.description {
        updates.push(format!("description = ${}", param_index));
        params.push(description);
        param_index += 1;
    }

    if let Some(completed) = update_task.completed {
        updates.push(format!("completed = ${}", param_index));
        params.push(&completed);
        param_index += 1;
    }

    if let Some(ref priority) = update_task.priority {
        updates.push(format!("priority = ${}", param_index));
        params.push(priority);
    }

    if updates.is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ApiError::new("validation_error", "No fields to update")),
        ));
    }

    let sql = format!(
        r#"
        UPDATE tasks
        SET {}
        WHERE id = $1
        RETURNING id, title, description, completed, priority AS "priority: TaskPriority", created_at, updated_at
        "#,
        updates.join(", ")
    );

    // Execute update with error handling
    let task = match sqlx::query_as::<_, Task>(&sql) {
        mut query => {
            query = query.bind(task_id);
            if let Some(ref title) = update_task.title {
                query = query.bind(title.trim());
            }
            if let Some(ref description) = update_task.description {
                query = query.bind(description);
            }
            if let Some(completed) = update_task.completed {
                query = query.bind(completed);
            }
            if let Some(ref priority) = update_task.priority {
                query = query.bind(priority);
            }
            query
        }
    }
    .fetch_optional(&pool)
    .await
    .map_err(|e| {
        eprintln!("Database error updating task: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ApiError::new("database_error", "Failed to update task")),
        )
    })?
    .ok_or_else(|| {
        (
            StatusCode::NOT_FOUND,
            Json(ApiError::new("not_found", "Task not found")),
        )
    })?;

    Ok(Json(TaskResponse { task }))
}

// DELETE: Remove a task
pub async fn delete_task(
    State(pool): State<PgPool>,
    Path(task_id): Path<Uuid>,
) -> Result<StatusCode, (StatusCode, Json<ApiError>)> {
    let result = sqlx::query!("DELETE FROM tasks WHERE id = $1", task_id)
        .execute(&pool)
        .await
        .map_err(|e| {
            eprintln!("Database error deleting task: {}", e);
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(ApiError::new("database_error", "Failed to delete task")),
            )
        })?;

    if result.rows_affected() == 0 {
        return Err((
            StatusCode::NOT_FOUND,
            Json(ApiError::new("not_found", "Task not found")),
        ));
    }

    Ok(StatusCode::NO_CONTENT)
}

// Health check with database statistics
pub async fn health_check(
    State(pool): State<PgPool>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<ApiError>)> {
    let db_stats = get_database_stats(&pool).await.map_err(|e| {
        eprintln!("Database error in health check: {}", e);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ApiError::new("database_error", "Health check failed")),
        )
    })?;

    Ok(Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "database": db_stats
    })))
}
```

### Step 5: Wire Up the Complete API

Update `src/main.rs` to create the full REST API:

```rust
mod models;
mod database;
mod handlers;

use axum::{
    routing::{get, post, put, delete},
    Router,
};
use database::initialize_database;
use handlers::*;
use sqlx::PgPool;

#[shuttle_runtime::main]
async fn main(
    #[shuttle_shared_db::Postgres] pool: PgPool,
) -> shuttle_axum::ShuttleAxum {
    // Initialize database schema
    initialize_database(&pool)
        .await
        .expect("Failed to initialize database");

    // Build comprehensive REST API
    let app = Router::new()
        // Health endpoint
        .route("/health", get(health_check))

        // Task CRUD operations
        .route("/tasks", get(list_tasks).post(create_task))
        .route("/tasks/:id", get(get_task).put(update_task).delete(delete_task))

        // Apply shared database state
        .with_state(pool);

    Ok(app.into())
}
```

### Step 6: Test Your REST API

Test the complete API functionality:

```bash
shuttle run
```

**Test all CRUD operations:**

```bash
# CREATE: Add tasks
curl -X POST "http://localhost:8000/tasks" \
  -H "Content-Type: application/json" \
  -d '{"title": "Build REST API", "priority": "high"}'

curl -X POST "http://localhost:8000/tasks" \
  -H "Content-Type: application/json" \
  -d '{"title": "Write tests", "description": "Unit and integration tests", "priority": "medium"}'

# READ: List all tasks
curl "http://localhost:8000/tasks"

# READ: List with filtering
curl "http://localhost:8000/tasks?completed=false&priority=high"

# READ: Get specific task (replace with actual ID from creation)
curl "http://localhost:8000/tasks/YOUR_TASK_ID"

# UPDATE: Modify task
curl -X PUT "http://localhost:8000/tasks/YOUR_TASK_ID" \
  -H "Content-Type: application/json" \
  -d '{"completed": true, "priority": "medium"}'

# DELETE: Remove task
curl -X DELETE "http://localhost:8000/tasks/YOUR_TASK_ID"

# Health check
curl "http://localhost:8000/health"
```

### Step 7: Test Error Handling

Verify proper error responses:

```bash
# Test validation errors
curl -X POST "http://localhost:8000/tasks" \
  -H "Content-Type: application/json" \
  -d '{"title": "", "priority": "high"}'

# Test not found errors
curl "http://localhost:8000/tasks/00000000-0000-0000-0000-000000000000"

# Test invalid JSON
curl -X POST "http://localhost:8000/tasks" \
  -H "Content-Type: application/json" \
  -d '{"title": "Invalid JSON"'
```

### Step 8: Deploy Your API

Deploy the TaskFlow API to production:

```bash
shuttle deploy
```

Test your live API:

```bash
# Replace with your deployed URL
export API_URL="https://taskflow-api.shuttle.app"

# Test production endpoints
curl "$API_URL/health"
curl -X POST "$API_URL/tasks" \
  -H "Content-Type: application/json" \
  -d '{"title": "Production task", "priority": "critical"}'
```

## What You've Learned

You've mastered these **key Shuttle API concepts**:

- **HTTP Routing** - RESTful endpoints with Axum and automatic JSON handling
- **Database Integration** - Shared connection pools and optimized queries
- **Request Validation** - Input sanitization and structured error responses
- **State Management** - Efficient resource sharing across HTTP handlers
- **Custom Types** - PostgreSQL enums and type-safe database operations
- **Production Deployment** - Zero-config API hosting with automatic HTTPS
- **Error Handling** - Proper HTTP status codes and client-friendly error messages

## Troubleshooting

**Database connection errors?**

- Shuttle automatically provisions PostgreSQL with optimized connection pooling
- Check that schema initialization completed without errors

**JSON parsing failures?**

- Verify request `Content-Type: application/json` headers
- Check that request body matches the expected struct fields

**Route conflicts?**

- Ensure path parameters like `/:id` don't conflict with static routes
- Check that HTTP methods are correctly specified

**Validation errors not showing?**

- Verify error handling middleware is properly configured
- Check that validation logic returns appropriate HTTP status codes

## Next Steps

Expand your API skills:

1. **Add Authentication** - Secure your API with [Authentication Tutorial](/tutorials/intermediate/authentication)
2. **Database Mastery** - Learn advanced patterns with [Database Tutorial](/tutorials/beginner/databases-with-rust)
3. **Real-time Features** - Add WebSockets with [Chat App Tutorial](/tutorials/intermediate/websocket-chat-app-js)
