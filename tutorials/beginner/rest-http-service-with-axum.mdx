---
title: "Building Your First REST API with Axum"
description: "Learn to build a complete task manager API with Axum by creating endpoints, handling JSON, and adding persistence"
icon: "code"
---

## Learning Objectives

By the end of this tutorial, you will have built a working task manager API and learned how to:

- Create HTTP routes that respond to different request methods
- Handle JSON requests and responses
- Work with path parameters for dynamic routing
- Store and retrieve data using in-memory state
- Test your API endpoints

## Prerequisites

- Basic Rust knowledge (structs, functions, async/await)
- [Shuttle CLI installed](/getting-started/installation)
- Familiarity with REST API concepts (GET, POST, PUT, DELETE)

**Time Required**: 45-60 minutes

## What We're Building

We'll create a **Task Manager API** where users can:

- Get a list of all tasks (`GET /tasks`)
- Get a specific task by ID (`GET /tasks/{id}`)
- Create new tasks (`POST /tasks`)
- Update existing tasks (`PUT /tasks/{id}`)
- Delete tasks (`DELETE /tasks/{id}`)

Each task will have an ID, title, description, and completion status.

## Step 1: Create Your Project

First, let's create a new Shuttle project with Axum:

```bash
shuttle init --template axum task-manager
cd task-manager
```

You'll see this starting code in `src/main.rs`:

```rust
use axum::{routing::get, Router};

async fn hello_world() -> &'static str {
    "Hello, world!"
}

#[shuttle_runtime::main]
async fn main() -> shuttle_axum::ShuttleAxum {
    let router = Router::new().route("/", get(hello_world));

    Ok(router.into())
}
```

Let's test this works:

```bash
shuttle run
```

Visit `http://localhost:8000` in your browser. You should see "Hello, world!" displayed.

**What to notice**: The `#[shuttle_runtime::main]` macro wraps your Axum router for Shuttle deployment. The `Router::new()` creates a new router, and `.route()` adds a path with a handler function.

## Step 2: Create Your First Task Endpoint

Now we'll create our first real API endpoint. Replace the contents of `src/main.rs` with:

```rust
use axum::{
    routing::get,
    Router,
    Json,
    http::StatusCode,
    response::IntoResponse,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone)]
struct Task {
    id: u32,
    title: String,
    description: String,
    completed: bool,
}

async fn get_tasks() -> impl IntoResponse {
    let tasks = vec![
        Task {
            id: 1,
            title: "Learn Rust".to_string(),
            description: "Study the Rust programming language".to_string(),
            completed: false,
        },
        Task {
            id: 2,
            title: "Build an API".to_string(),
            description: "Create a REST API with Axum".to_string(),
            completed: true,
        },
    ];

    (StatusCode::OK, Json(tasks))
}

#[shuttle_runtime::main]
async fn main() -> shuttle_axum::ShuttleAxum {
    let router = Router::new()
        .route("/tasks", get(get_tasks));

    Ok(router.into())
}
```

Start your server again:

```bash
shuttle run
```

Now visit `http://localhost:8000/tasks`. You should see JSON output like this:

```json
[
  {
    "id": 1,
    "title": "Learn Rust",
    "description": "Study the Rust programming language",
    "completed": false
  },
  {
    "id": 2,
    "title": "Build an API",
    "description": "Create a REST API with Axum",
    "completed": true
  }
]
```

**What to notice**: We've defined a `Task` struct with Serde annotations for JSON conversion. The `Json()` wrapper automatically converts our Rust data to JSON, and `StatusCode::OK` sets the HTTP response code to 200.

## Step 3: Add a Single Task Endpoint

Let's add an endpoint to get individual tasks by ID. Add this function before the `main` function:

```rust
use axum::extract::Path;

async fn get_task(Path(id): Path<u32>) -> impl IntoResponse {
    let task = Task {
        id,
        title: format!("Task {}", id),
        description: format!("Description for task {}", id),
        completed: false,
    };

    (StatusCode::OK, Json(task))
}
```

Update your router in the `main` function:

```rust
let router = Router::new()
    .route("/tasks", get(get_tasks))
    .route("/tasks/:id", get(get_task));
```

Restart your server and test the new endpoint:

```bash
curl http://localhost:8000/tasks/42
```

You should see:

```json
{
  "id": 42,
  "title": "Task 42",
  "description": "Description for task 42",
  "completed": false
}
```

**What to notice**: The `Path(id): Path<u32>` extracts the ID from the URL path. The `:id` in the route matches any number, and Axum automatically converts it to a `u32`.

## Step 4: Add Task Creation

Now we'll add the ability to create new tasks. First, let's create a request type for new tasks:

```rust
#[derive(Deserialize)]
struct CreateTask {
    title: String,
    description: String,
}
```

Add this handler function:

```rust
async fn create_task(Json(payload): Json<CreateTask>) -> impl IntoResponse {
    let new_task = Task {
        id: 99, // We'll make this dynamic later
        title: payload.title,
        description: payload.description,
        completed: false,
    };

    (StatusCode::CREATED, Json(new_task))
}
```

Update your imports and router:

```rust
use axum::{
    routing::{get, post},
    Router,
    Json,
    http::StatusCode,
    response::IntoResponse,
    extract::Path,
};

// In main function:
let router = Router::new()
    .route("/tasks", get(get_tasks).post(create_task))
    .route("/tasks/:id", get(get_task));
```

Test creating a task:

```bash
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "New Task", "description": "A task created via API"}'
```

You should see the created task returned with ID 99 and status 201 Created.

**What to notice**: `Json(payload): Json<CreateTask>` automatically parses the JSON request body into our Rust struct. We can chain multiple HTTP methods on the same route using `.get().post()`.

## Step 5: Add Persistent State

Our API currently doesn't remember tasks between requests. Let's add in-memory storage using Axum's state feature.

Add these imports:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use axum::extract::State;
```

Create an application state type:

```rust
type TaskStore = Arc<Mutex<HashMap<u32, Task>>>;

#[derive(Clone)]
struct AppState {
    tasks: TaskStore,
    next_id: Arc<Mutex<u32>>,
}
```

Update your handlers to use state. Replace the `get_tasks` function:

```rust
async fn get_tasks(State(state): State<AppState>) -> impl IntoResponse {
    let tasks = state.tasks.lock().unwrap();
    let tasks_vec: Vec<Task> = tasks.values().cloned().collect();

    (StatusCode::OK, Json(tasks_vec))
}
```

Replace the `get_task` function:

```rust
async fn get_task(
    State(state): State<AppState>,
    Path(id): Path<u32>
) -> impl IntoResponse {
    let tasks = state.tasks.lock().unwrap();

    match tasks.get(&id) {
        Some(task) => (StatusCode::OK, Json(task.clone())),
        None => (StatusCode::NOT_FOUND, Json(Task {
            id: 0,
            title: "Not found".to_string(),
            description: "Task not found".to_string(),
            completed: false,
        })),
    }
}
```

Replace the `create_task` function:

```rust
async fn create_task(
    State(state): State<AppState>,
    Json(payload): Json<CreateTask>
) -> impl IntoResponse {
    let mut next_id = state.next_id.lock().unwrap();
    let id = *next_id;
    *next_id += 1;

    let new_task = Task {
        id,
        title: payload.title,
        description: payload.description,
        completed: false,
    };

    state.tasks.lock().unwrap().insert(id, new_task.clone());

    (StatusCode::CREATED, Json(new_task))
}
```

Update your main function to initialize state:

```rust
#[shuttle_runtime::main]
async fn main() -> shuttle_axum::ShuttleAxum {
    let mut initial_tasks = HashMap::new();
    initial_tasks.insert(1, Task {
        id: 1,
        title: "Learn Rust".to_string(),
        description: "Study the Rust programming language".to_string(),
        completed: false,
    });

    let state = AppState {
        tasks: Arc::new(Mutex::new(initial_tasks)),
        next_id: Arc::new(Mutex::new(2)),
    };

    let router = Router::new()
        .route("/tasks", get(get_tasks).post(create_task))
        .route("/tasks/:id", get(get_task))
        .with_state(state);

    Ok(router.into())
}
```

Restart your server and test it:

```bash
# Get all tasks
curl http://localhost:8000/tasks

# Create a new task
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "Persistent Task", "description": "This task will be remembered"}'

# Get all tasks again - you should see your new task
curl http://localhost:8000/tasks
```

**What to notice**: The state persists between requests now. `State(state): State<AppState>` injects the shared state into each handler. We use `Arc<Mutex<>>` to safely share data between concurrent requests.

## Step 6: Complete the CRUD Operations

Let's add the final operations - updating and deleting tasks. Add these request types:

```rust
#[derive(Deserialize)]
struct UpdateTask {
    title: Option<String>,
    description: Option<String>,
    completed: Option<bool>,
}
```

Add the update handler:

```rust
async fn update_task(
    State(state): State<AppState>,
    Path(id): Path<u32>,
    Json(payload): Json<UpdateTask>
) -> impl IntoResponse {
    let mut tasks = state.tasks.lock().unwrap();

    match tasks.get_mut(&id) {
        Some(task) => {
            if let Some(title) = payload.title {
                task.title = title;
            }
            if let Some(description) = payload.description {
                task.description = description;
            }
            if let Some(completed) = payload.completed {
                task.completed = completed;
            }
            (StatusCode::OK, Json(task.clone()))
        }
        None => (StatusCode::NOT_FOUND, Json(Task {
            id: 0,
            title: "Not found".to_string(),
            description: "Task not found".to_string(),
            completed: false,
        })),
    }
}
```

Add the delete handler:

```rust
async fn delete_task(
    State(state): State<AppState>,
    Path(id): Path<u32>
) -> impl IntoResponse {
    let mut tasks = state.tasks.lock().unwrap();

    match tasks.remove(&id) {
        Some(_) => StatusCode::NO_CONTENT,
        None => StatusCode::NOT_FOUND,
    }
}
```

Update your imports and router:

```rust
use axum::{
    routing::{get, post, put, delete},
    Router,
    Json,
    http::StatusCode,
    response::IntoResponse,
    extract::{Path, State},
};

// In main function:
let router = Router::new()
    .route("/tasks", get(get_tasks).post(create_task))
    .route("/tasks/:id", get(get_task).put(update_task).delete(delete_task))
    .with_state(state);
```

Test the complete API:

```bash
# Create a task
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "Test Task", "description": "Testing updates"}'

# Update the task (assuming it got ID 2)
curl -X PUT http://localhost:8000/tasks/2 \
  -H "Content-Type: application/json" \
  -d '{"completed": true}'

# Get the updated task
curl http://localhost:8000/tasks/2

# Delete the task
curl -X DELETE http://localhost:8000/tasks/2

# Verify it's gone
curl http://localhost:8000/tasks/2
```

**What to notice**: We can chain multiple HTTP methods on the same route: `.get().put().delete()`. The `Option<>` fields in `UpdateTask` allow partial updates - users only need to send the fields they want to change.

## Step 7: Deploy Your API

Your API is complete! Let's deploy it to the cloud:

```bash
shuttle deploy
```

After deployment, Shuttle will give you a live URL like `https://task-manager-xyz.shuttle.app`. You can test your deployed API:

```bash
curl https://task-manager-xyz.shuttle.app/tasks
```

## What You've Accomplished

Congratulations! You've built a complete REST API with Axum that includes:

- ✅ **Multiple HTTP routes** with different methods (GET, POST, PUT, DELETE)
- ✅ **JSON request and response handling** using Serde
- ✅ **Dynamic path parameters** for resource identification
- ✅ **Persistent state management** with thread-safe storage
- ✅ **Complete CRUD operations** for task management
- ✅ **Cloud deployment** with Shuttle

## Key Concepts You've Learned

Through building this API, you've learned:

- **Router creation**: Using `Router::new()` and chaining routes
- **Handler functions**: Writing async functions that process requests
- **JSON serialization**: Converting between Rust structs and JSON
- **Path extraction**: Getting dynamic values from URLs
- **State management**: Sharing data between requests safely
- **HTTP status codes**: Returning appropriate response codes

## Next Steps

Now that you understand Axum basics, you can:

1. **Add a database** - Replace in-memory storage with PostgreSQL using `shuttle-shared-db`
2. **Add authentication** - Protect your API with user sessions
3. **Add validation** - Ensure request data meets your requirements
4. **Add error handling** - Create better error responses
5. **Add middleware** - Add logging, CORS, or rate limiting

Try our [Authentication tutorial](/tutorials/authentication) or [Database tutorial](/tutorials/databases-with-rust) next!

## Troubleshooting

**Server won't start?**

- Check that all dependencies are in `Cargo.toml`
- Ensure no other service is using port 8000

**JSON parsing errors?**

- Verify your request has `Content-Type: application/json` header
- Check that field names match your struct exactly

**State not persisting?**

- Remember state only persists while the server runs
- Restarting the server resets all data

**Deployment issues?**

- Run `shuttle project status` to check your project
- View logs with `shuttle logs`

You've successfully learned the fundamentals of building REST APIs with Axum!
